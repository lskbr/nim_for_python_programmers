#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2022-10-04 16:00+0000\n"
"PO-Revision-Date: 2022-10-04 18:39+0200\n"
"Last-Translator: \n"
"Language-Team: Nilo Menezes - Nim Brasil\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: Poedit 3.0.1\n"

#: Nim.wiki/Nim-for-Python-Programmers.md:0
msgid "Table Of Contents"
msgstr "Índice"

#: Nim.wiki/Nim-for-Python-Programmers.md:4
msgid "[English Version](https://github.com/nim-lang/Nim/wiki/Nim-for-Python-Programmers#table-of-contents)"
msgstr "[Versão em Inglês](https://github.com/nim-lang/Nim/wiki/Nim-for-Python-Programmers#table-of-contents)"

#: Nim.wiki/Nim-for-Python-Programmers.md:7
msgid "[Spanish Version](https://github.com/nim-lang/Nim/wiki/Nim-for-Python-Programmers-ES#tabla-de-contenidos)"
msgstr "[Versão em Espanhol](https://github.com/nim-lang/Nim/wiki/Nim-for-Python-Programmers-ES#tabla-de-contenidos)"

#: Nim.wiki/Nim-for-Python-Programmers.md:11
msgid "Comparison"
msgstr "Comparação"

#: Nim.wiki/Nim-for-Python-Programmers.md:13
msgid "Notes:"
msgstr "Notas:"

#: Nim.wiki/Nim-for-Python-Programmers.md:17
msgid "Python anonymous function (lambdas) are known to be slow compared to normal functions."
msgstr "Sabe-se que as funções anônimas do Python (lambdas) são lentas em comparação com as funções normais."

#: Nim.wiki/Nim-for-Python-Programmers.md:20
msgid "Python Regex claims to be PCRE compatible, but in practice PCRE Regexes may not work."
msgstr "O Python Regex afirma ser compatível com PCRE, mas na prática os PCRE Regexes podem não funcionar."

#: Nim.wiki/Nim-for-Python-Programmers.md:23
msgid "Python \"multi-line\" anonymous functions may require using `;` and Linters/IDE may complain about it."
msgstr "As funções anônimas “de várias linhas” do Python podem exigir o uso de `;` e o Linters/IDE pode reclamar disso."

#: Nim.wiki/Nim-for-Python-Programmers.md:27
msgid "Variables"
msgstr "Variáveis"

#: Nim.wiki/Nim-for-Python-Programmers.md:28
msgid ""
"Creating a new variable uses `var` or `let` or `const`.\n"
"Nim has immutability and compile-time function execution.\n"
"You can assign functions to variables."
msgstr ""
"A criação de uma nova variável usa `var` ou `let` ou `const`.\n"
"Nim tem imutabilidade e execução de funções em tempo de compilação.\n"
"Você pode atribuir funções às variáveis."

#: Nim.wiki/Nim-for-Python-Programmers.md:31
msgid "[For advanced users, it is possible to skip variable Auto-Initialization.](https://nim-lang.github.io/Nim/manual.html#statements-and-expressions-var-statement)"
msgstr "[Para usuários avançados, é possível ignorar a inicialização automática de variáveis.] (https://nim-lang.github.io/Nim/manual.html#statements-and-expressions-var-statement)"

#: Nim.wiki/Nim-for-Python-Programmers.md:33
msgid "Variable Naming"
msgstr "Nomeação de variáveis"

#: Nim.wiki/Nim-for-Python-Programmers.md:34
msgid "Variables can be multi-line without \"escaping\" them or using parentheses. This is useful for long lines and long ternary operators. Minimal example:"
msgstr "As variáveis podem ter várias linhas sem “escapar” delas ou usar parênteses. Isso é útil para linhas longas e operadores ternários longos. Exemplo mínimo:"

#: Nim.wiki/Nim-for-Python-Programmers.md:36
msgid ""
"variable = 666 +  \\\n"
"  420 *  \\\n"
"  42 -   \\\n"
"  9           \n"
"\n"
"assert variable == 18297"
msgstr ""
"variável = 666 +\\\n"
" 420 *\\\n"
" 42 -\\\n"
" 9 \n"
"\n"
"variável de afirmação = 18297"

#: Nim.wiki/Nim-for-Python-Programmers.md:37 Nim.wiki/Nim-for-Python-Programmers.md:72 Nim.wiki/Nim-for-Python-Programmers.md:83 Nim.wiki/Nim-for-Python-Programmers.md:89 Nim.wiki/Nim-for-Python-Programmers.md:103 Nim.wiki/Nim-for-Python-Programmers.md:113 Nim.wiki/Nim-for-Python-Programmers.md:127
#: Nim.wiki/Nim-for-Python-Programmers.md:144 Nim.wiki/Nim-for-Python-Programmers.md:178 Nim.wiki/Nim-for-Python-Programmers.md:297 Nim.wiki/Nim-for-Python-Programmers.md:527 Nim.wiki/Nim-for-Python-Programmers.md:541 Nim.wiki/Nim-for-Python-Programmers.md:560 Nim.wiki/Nim-for-Python-Programmers.md:584
#: Nim.wiki/Nim-for-Python-Programmers.md:595 Nim.wiki/Nim-for-Python-Programmers.md:606 Nim.wiki/Nim-for-Python-Programmers.md:621 Nim.wiki/Nim-for-Python-Programmers.md:628 Nim.wiki/Nim-for-Python-Programmers.md:642 Nim.wiki/Nim-for-Python-Programmers.md:666 Nim.wiki/Nim-for-Python-Programmers.md:677
#: Nim.wiki/Nim-for-Python-Programmers.md:713 Nim.wiki/Nim-for-Python-Programmers.md:718 Nim.wiki/Nim-for-Python-Programmers.md:723 Nim.wiki/Nim-for-Python-Programmers.md:748 Nim.wiki/Nim-for-Python-Programmers.md:759 Nim.wiki/Nim-for-Python-Programmers.md:776 Nim.wiki/Nim-for-Python-Programmers.md:785
#: Nim.wiki/Nim-for-Python-Programmers.md:794 Nim.wiki/Nim-for-Python-Programmers.md:805 Nim.wiki/Nim-for-Python-Programmers.md:816 Nim.wiki/Nim-for-Python-Programmers.md:824 Nim.wiki/Nim-for-Python-Programmers.md:837 Nim.wiki/Nim-for-Python-Programmers.md:857 Nim.wiki/Nim-for-Python-Programmers.md:892
#: Nim.wiki/Nim-for-Python-Programmers.md:897 Nim.wiki/Nim-for-Python-Programmers.md:942 Nim.wiki/Nim-for-Python-Programmers.md:1009 Nim.wiki/Nim-for-Python-Programmers.md:1070 Nim.wiki/Nim-for-Python-Programmers.md:1076
msgid ":arrow_up: Python :arrow_up: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :arrow_down: Nim :arrow_down:"
msgstr ":arrow_up: Python:arrow_up: :arrow_down: NIM:arrow_down:"

#: Nim.wiki/Nim-for-Python-Programmers.md:39
msgid ""
"var variable = 666 +\n"
"  420 *\n"
"  42 -\n"
"  9\n"
"\n"
"assert variable == 18297"
msgstr ""
"variável var = 666 +\n"
" 420 *\n"
" 42 -\n"
" 9\n"
"\n"
"variável de afirmação = 18297"

#: Nim.wiki/Nim-for-Python-Programmers.md:40
msgid "This works with function calls too:"
msgstr "Isso também funciona com chamadas de função:"

#: Nim.wiki/Nim-for-Python-Programmers.md:42
msgid ""
"import std/strutils\n"
"\n"
"var variable = \"  12345  \"\n"
"  .strip\n"
"  .parseInt\n"
"\n"
"assert variable == 12345"
msgstr ""
"importar std/strutils\n"
"\n"
"variável var = \"12345”\n"
" .strip\n"
" .parseint\n"
"\n"
"variável de afirmação = 12345"

#: Nim.wiki/Nim-for-Python-Programmers.md:43
msgid "You can use underscores, new lines, and whitespace in variable names:"
msgstr "Você pode usar sublinhados, novas linhas e espaços em branco nos nomes das variáveis:"

#: Nim.wiki/Nim-for-Python-Programmers.md:45
msgid ""
"let `this must  be  \n"
"     positive`: Positive = 42\n"
"\n"
"assert this_must_be_positive == 42\n"
"\n"
"const `this is my nice named variable` = 42"
msgstr ""
"deixe `isso deve ser \n"
" positivo`: Positivo = 42\n"
"\n"
"afirme this_must_be_positive = 42\n"
"\n"
"const `esta é minha bela variável nomeada` = 42"

#: Nim.wiki/Nim-for-Python-Programmers.md:46
msgid "[You can use reserved keywords as variable names.](https://nim-lang.github.io/Nim/manual.html#lexical-analysis-stropping)"
msgstr "[Você pode usar palavras-chave reservadas como nomes de variáveis.] (https://nim-lang.github.io/Nim/manual.html#lexical-analysis-stropping)"

#: Nim.wiki/Nim-for-Python-Programmers.md:48
msgid "It's okay to use `var` while learning Nim or for quick prototyping, although it's much better to learn the difference between different variable declarations."
msgstr "Não há problema em usar `var` enquanto aprende Nim ou para prototipagem rápida, embora seja muito melhor aprender a diferença entre diferentes declarações de variáveis."

#: Nim.wiki/Nim-for-Python-Programmers.md:50
msgid "Consistent Spacing"
msgstr "Espaçamento consistente"

#: Nim.wiki/Nim-for-Python-Programmers.md:51
msgid "Spaces must be consistent on your code, mainly around operators:"
msgstr "Os espaços devem ser consistentes em seu código, principalmente em torno dos operadores:"

#: Nim.wiki/Nim-for-Python-Programmers.md:53
msgid ""
"echo 2 - 1 # OK\n"
"echo 2-1   # OK"
msgstr ""
"echo 2 - 1 # OK\n"
"echo 2-1 # OK"

#: Nim.wiki/Nim-for-Python-Programmers.md:54
msgid "Bad inconsistent spaces:"
msgstr "Espaços inconsistentes incorretos:"

#: Nim.wiki/Nim-for-Python-Programmers.md:56
msgid ""
"echo 2 -1 # Error\n"
"#      ^ parses as \"-1\""
msgstr ""
"echo 2 -1 # Erro\n"
"# ^ analisa como “-1\""

#: Nim.wiki/Nim-for-Python-Programmers.md:57
msgid "Omitting spaces on your code has no effect on performance."
msgstr "Omitir espaços em seu código não afeta o desempenho."

#: Nim.wiki/Nim-for-Python-Programmers.md:59
msgid "All operators are functions in Nim."
msgstr "Todos os operadores são funções no Nim."

#: Nim.wiki/Nim-for-Python-Programmers.md:61
msgid "Scoping"
msgstr "Escopo"

#: Nim.wiki/Nim-for-Python-Programmers.md:64
msgid "Scope \"leaks\", \"bugs\", \"glitches\", etc."
msgstr "Escopo: “vazamentos”, “bugs”, “falhas”, etc."

#: Nim.wiki/Nim-for-Python-Programmers.md:68
msgid ""
"for x in range(0, 9):\n"
"  if x == 6:\n"
"    print(x)\n"
"\n"
"print(x)"
msgstr ""
"para x no intervalo (0, 9):\n"
" se x == 6:\n"
" imprimir (x)\n"
"\n"
"imprimir (x)"

#: Nim.wiki/Nim-for-Python-Programmers.md:69 Nim.wiki/Nim-for-Python-Programmers.md:75 Nim.wiki/Nim-for-Python-Programmers.md:141 Nim.wiki/Nim-for-Python-Programmers.md:147
msgid "Output:"
msgstr "Saída:"

#: Nim.wiki/Nim-for-Python-Programmers.md:71
msgid ""
"6\n"
"8  # Leak!"
msgstr ""
"6\n"
"8 # Vazamento!"

#: Nim.wiki/Nim-for-Python-Programmers.md:74
msgid ""
"for x in 0..9:\n"
"  if x == 6:\n"
"    echo x\n"
"\n"
"echo x"
msgstr ""
"para x em 0,9:\n"
" se x == 6:\n"
" eco x\n"
"\n"
"eco x"

#: Nim.wiki/Nim-for-Python-Programmers.md:77
msgid "Error: undeclared identifier: 'x'"
msgstr "Erro: identificador não declarado: 'x'"

#: Nim.wiki/Nim-for-Python-Programmers.md:78
msgid ""
"Note that in the example above we use a simple `int`, so the problem may not seem severe. But if `x` were a few gigabytes of RAM in size,\n"
"it would \"leak\" out of the `for` loop to the rest of the outer or main scope instead of being reclaimed. Nim avoids this problem."
msgstr ""
"Observe que, no exemplo acima, usamos um simples `int`, então o problema pode não parecer grave. Mas se `x` tivesse alguns gigabytes de RAM,\n"
"ele “vazaria” do loop `for` para o resto do escopo externo ou principal em vez de ser recuperado. Nim evita esse problema."

#: Nim.wiki/Nim-for-Python-Programmers.md:80 Nim.wiki/Nim-for-Python-Programmers.md:86 Nim.wiki/Nim-for-Python-Programmers.md:108 Nim.wiki/Nim-for-Python-Programmers.md:467
msgid "Another example:"
msgstr "Outro exemplo:"

#: Nim.wiki/Nim-for-Python-Programmers.md:82
msgid ""
"x = 0\n"
"y = 0\n"
"\n"
"def example():\n"
"  x = 1\n"
"  y = 1\n"
"  class C:\n"
"    nonlocal x, y\n"
"    assert x == 1 and y == 1\n"
"    x = 2\n"
"\n"
"example()"
msgstr ""
"x = 0\n"
"y = 0\n"
"\n"
"def example ():\n"
" x = 1\n"
" y = 1\n"
" classe C:\n"
" não local x, y\n"
" assert x == 1 e y == 1\n"
" x = 2\n"
"\n"
"exemplo ()"

#: Nim.wiki/Nim-for-Python-Programmers.md:85
msgid ""
"var x = 0\n"
"var y = 0\n"
"\n"
"proc example() =\n"
"  var x = 1\n"
"  var y = 1\n"
"  type C = object\n"
"  assert x == 1 and y == 1\n"
"  x = 2\n"
"\n"
"example()"
msgstr ""
"var x = 0\n"
"var y = 0\n"
"\n"
"exemplo de proc () =\n"
" var x = 1\n"
" var y = 1\n"
" tipo C = objeto\n"
" assert x == 1 e y == 1\n"
" x = 2\n"
"\n"
"exemplo ()"

#: Nim.wiki/Nim-for-Python-Programmers.md:88
msgid ""
"x = 0\n"
"y = 0\n"
"\n"
"def example():\n"
"  x = 1\n"
"  y = 1\n"
"  class C:\n"
"    nonlocal x, y\n"
"    assert x == 1 and y == 1\n"
"    x = 2\n"
"    try:\n"
"      raise\n"
"    except Exception as _:\n"
"      pass\n"
"\n"
"example()"
msgstr ""
"x = 0\n"
"y = 0\n"
"\n"
"def example ():\n"
" x = 1\n"
" y = 1\n"
" classe C:\n"
" não local x, y\n"
" assert x == 1 e y == 1\n"
" x = 2\n"
" tente:\n"
" erguer\n"
" exceto Exceção como _:\n"
" passar\n"
"\n"
"exemplo ()"

#: Nim.wiki/Nim-for-Python-Programmers.md:91
msgid ""
"var x = 0\n"
"var y = 0\n"
"\n"
"proc example() =\n"
"  var x = 1\n"
"  var y = 1\n"
"  type C = object\n"
"  assert x == 1 and y == 1\n"
"  x = 2\n"
"  try:\n"
"    raise\n"
"  except Exception as y:\n"
"    discard\n"
"\n"
"example()"
msgstr ""
"var x = 0\n"
"var y = 0\n"
"\n"
"exemplo de proc () =\n"
" var x = 1\n"
" var y = 1\n"
" tipo C = objeto\n"
" assert x == 1 e y == 1\n"
" x = 2\n"
" tente:\n"
" erguer\n"
" exceto Exceção como y:\n"
" descartar\n"
"\n"
"exemplo ()"

#: Nim.wiki/Nim-for-Python-Programmers.md:92
msgid "Boolean conditionals"
msgstr "Condicionais booleanos"

#: Nim.wiki/Nim-for-Python-Programmers.md:95
msgid "Boolean comparisons \"bugs\", \"glitches\", etc."
msgstr "Comparações booleanas “bugs”, “falhas”, etc."

#: Nim.wiki/Nim-for-Python-Programmers.md:99
msgid "assert True == not False"
msgstr "afirmar Verdadeiro == não Falso"

#: Nim.wiki/Nim-for-Python-Programmers.md:100
msgid "Fails with the error:"
msgstr "Falha com o erro:"

#: Nim.wiki/Nim-for-Python-Programmers.md:102 Nim.wiki/Nim-for-Python-Programmers.md:653
msgid "SyntaxError: invalid syntax."
msgstr "SyntaxError: sintaxe inválida."

#: Nim.wiki/Nim-for-Python-Programmers.md:105
msgid "The Nim example compiles and runs without incident; the operator precedence is resolved correctly:"
msgstr "O exemplo do Nim é compilado e executado sem incidentes; a precedência do operador é resolvida corretamente:"

#: Nim.wiki/Nim-for-Python-Programmers.md:107
msgid "assert true == not false"
msgstr "afirmar verdadeiro == não falso"

#: Nim.wiki/Nim-for-Python-Programmers.md:110
msgid ""
"assert False + 1\n"
"assert not True - 1"
msgstr ""
"afirmação falsa + 1\n"
"afirmar que não é verdade - 1"

#: Nim.wiki/Nim-for-Python-Programmers.md:111
msgid "This runs because `bool` is a subtype of `int` in Python, so it supports the same mathematical operations. In Nim this is not the case:"
msgstr "Isso é executado porque `bool` é um subtipo de `int` em Python, portanto, ele suporta as mesmas operações matemáticas. Em Nim, esse não é o caso:"

#: Nim.wiki/Nim-for-Python-Programmers.md:115
msgid ""
"assert false + 1\n"
"assert not true - 1"
msgstr ""
"afirmação falsa + 1\n"
"afirmar que não é verdade - 1"

#: Nim.wiki/Nim-for-Python-Programmers.md:116
msgid "Does not Compile:"
msgstr "Não compila:"

#: Nim.wiki/Nim-for-Python-Programmers.md:118
msgid "Error: type mismatch: got <bool, int>"
msgstr "Erro: incompatibilidade de tipo: got <bool, int>"

#: Nim.wiki/Nim-for-Python-Programmers.md:119
msgid "block"
msgstr "bloco"

#: Nim.wiki/Nim-for-Python-Programmers.md:120
msgid "`block` explicitly creates a new scope, without the overhead of a function. It can have a \"name\" without the name polluting the local namespace, and can be interrupted anywhere without requiring `return`."
msgstr "`block` cria explicitamente um novo escopo, sem a sobrecarga de uma função. Ele pode ter um “nome” sem que o nome polua o namespace local e pode ser interrompido em qualquer lugar sem exigir `retornar`."

#: Nim.wiki/Nim-for-Python-Programmers.md:122
msgid "`block` can be used with `var`, `let` and `const` too."
msgstr "`block` também pode ser usado com `var`, `let` e `const`."

#: Nim.wiki/Nim-for-Python-Programmers.md:124
msgid "Imagine that you need to get out of a nested `if`, without executing any other code from other `if` and `else` blocks. You can do:"
msgstr "Imagine que você precise sair de um `if` aninhado, sem executar nenhum outro código de outros blocos `if` e `else`. Você pode fazer:"

#: Nim.wiki/Nim-for-Python-Programmers.md:126
msgid ""
"print(\"Before\")\n"
"\n"
"# this is a function, has overhead, pollutes namespace, must return to interrupt, etc.\n"
"def example():\n"
"  if True:\n"
"    print(\"Inside if true\")\n"
"    if 42 > 0:\n"
"      print(\"Inside if 42 > 0\")\n"
"      if 'z' > 'a':\n"
"        print(\"Inside if z > a\")\n"
"        return  # Must return to interrupt\n"
"        if 3.14 > 0.0:\n"
"          print(\"Inside if 3.14 > 0.0\")\n"
"      else:\n"
"        print(\"else of z > a\")\n"
"    else:\n"
"      print(\"else of 42 > 0\")\n"
"  else:\n"
"    print(\"else of true\")\n"
"\n"
"example()  # example in namespace\n"
"print(\"After\")"
msgstr ""
"imprimir (“Antes”)\n"
"\n"
"# esta é uma função, tem sobrecarga, polui o namespace, deve retornar para interromper, etc.\n"
"def example ():\n"
" se for verdadeiro:\n"
" print (“Inside if true”)\n"
" se 42 > 0:\n"
" print (“Dentro de 42 > 0\")\n"
" se 'z' > 'a':\n"
" print (“Dentro de z > a”)\n"
" retornar # Deve retornar para interromper\n"
" se 3.14 > 0.0:\n"
" imprimir (“Dentro de 3,14 > 0,0\")\n"
" senão:\n"
" print (“senão de z > a”)\n"
" senão:\n"
" print (“senão de 42 > 0\")\n"
" senão:\n"
" print (“else of true”)\n"
"\n"
"exemplo () # exemplo em namespace\n"
"imprimir (“Depois”)"

#: Nim.wiki/Nim-for-Python-Programmers.md:129
msgid ""
"echo \"Before\"\n"
"\n"
"block example:  # Creates a new explicit named scope. This is not a function; there is no overhead.\n"
"  if true:\n"
"    echo \"Inside if true\"\n"
"    if 42 > 0:\n"
"      echo \"Inside if 42 > 0\"\n"
"      if 'z' > 'a':\n"
"        echo \"Inside if z > a\"\n"
"        break example  # Gets out of block example.\n"
"        if 3.14 > 0.0:\n"
"          echo \"Inside if 3.14 > 0.0\"\n"
"      else:\n"
"        echo \"else of z > a\"\n"
"    else:\n"
"      echo \"else of 42 > 0\"\n"
"  else:\n"
"    echo \"else of true\"\n"
"\n"
"# No function call. \"example\" is not polluting the local namespace.\n"
"echo \"After\""
msgstr ""
"echo “Antes”\n"
"\n"
"exemplo de bloco: # Cria um novo escopo nomeado explícito. Isso não é uma função; não há sobrecarga.\n"
" se for verdade:\n"
" echo “Por dentro, se for verdade”\n"
" se 42 > 0:\n"
" echo “Dentro de 42 > 0\"\n"
" se 'z' > 'a':\n"
" echo “Dentro de z > a”\n"
" exemplo de quebra # Exemplo de sai do bloco.\n"
" se 3.14 > 0.0:\n"
" echo “Dentro de 3,14 > 0,0\"\n"
" senão:\n"
" echo “senão de z > a”\n"
" senão:\n"
" echo “senão de 42 > 0\"\n"
" senão:\n"
" echo “senão verdadeiro”\n"
"\n"
"# Sem chamada de função. “exemplo” não está poluindo o namespace local.\n"
"echo “Depois”"

#: Nim.wiki/Nim-for-Python-Programmers.md:132
msgid "https://nim-lang.github.io/Nim/manual.html#statements-and-expressions-block-statement"
msgstr "https://nim-lang.github.io/Nim/manual.html#statements-and-expressions-block-statement"

#: Nim.wiki/Nim-for-Python-Programmers.md:135
msgid "https://nim-lang.github.io/Nim/manual.html#statements-and-expressions-block-expression"
msgstr "https://nim-lang.github.io/Nim/manual.html#statements-and-expressions-block-expression"

#: Nim.wiki/Nim-for-Python-Programmers.md:139
msgid "Mutable arguments"
msgstr "Argumentos mutáveis"

#: Nim.wiki/Nim-for-Python-Programmers.md:140
msgid ""
"def example(argument = [0]):\n"
"  argument.append(42)\n"
"  return argument\n"
"\n"
"print(example())\n"
"print(example())\n"
"print(example())"
msgstr ""
"exemplo de definição (argumento = [0]):\n"
" argumento.append (42)\n"
" argumento de retorno\n"
"\n"
"imprimir (exemplo ())\n"
"imprimir (exemplo ())\n"
"imprimir (exemplo ())"

#: Nim.wiki/Nim-for-Python-Programmers.md:143
msgid ""
"[0, 42]\n"
"[0, 42, 42]\n"
"[0, 42, 42, 42]"
msgstr ""
"[0, 42]\n"
"[0, 42, 42]\n"
"[0, 42, 42, 42]"

#: Nim.wiki/Nim-for-Python-Programmers.md:146
msgid ""
"func example(argument = @[0]): auto =\n"
"  argument.add 42\n"
"  return argument\n"
"\n"
"echo example()\n"
"echo example()\n"
"echo example()"
msgstr ""
"exemplo de função (argumento = @ [0]): auto =\n"
" argumento.add 42\n"
" argumento de retorno\n"
"\n"
"exemplo de eco ()\n"
"exemplo de eco ()\n"
"exemplo de eco ()"

#: Nim.wiki/Nim-for-Python-Programmers.md:149
msgid ""
"Error: type mismatch: got <seq[int], int literal(42)>\n"
"\n"
"but expected one of: \n"
"proc add[T](x: var seq[T]; y: sink T)\n"
"  first type mismatch at position: 1\n"
"  required type for x: var seq[T]\n"
"  but expression 'argument' is immutable, not 'var'"
msgstr ""
"Erro: incompatibilidade de tipo: got <seq [int], int literal (42) >\n"
"\n"
"mas esperava um dos seguintes: \n"
"proc add [T] (x: var seq [T]; y: pia T)\n"
" primeiro tipo de incompatibilidade na posição: 1\n"
" tipo necessário para x: var seq [T]\n"
" mas a expressão 'argumento' é imutável, não 'var'"

#: Nim.wiki/Nim-for-Python-Programmers.md:150
msgid "Imports"
msgstr "Importações"

#: Nim.wiki/Nim-for-Python-Programmers.md:152
msgid "**Your modules and types are not going to collide!, even if you have types named like modules, just chill and keep coding...**"
msgstr "**Seus módulos e tipos não vão colidir! , mesmo que você tenha tipos chamados de módulos, relaxe e continue codificando... **"

#: Nim.wiki/Nim-for-Python-Programmers.md:154
msgid "In Nim, ``import std/math`` imports all of the symbols from the ``math`` module (``sin``, ``cos``, etc) so that they can be used unqualified. The Python equivalent is ``from math import *``."
msgstr "Em Nim, ``import std/math`` importa todos os símbolos do módulo ``math`` (``sin``, ``cos``, etc) para que eles possam ser usados sem qualificação. O equivalente em Python é ``from math import *``."

#: Nim.wiki/Nim-for-Python-Programmers.md:156
msgid "If you prefer to not import all the symbols, and always use qualified names instead, the Nim code is ``from std/math import nil``. Then you can call ``math.sin()``, ``math.cos()``, etc. The Python equivalent is ``import math``."
msgstr "Se você preferir não importar todos os símbolos e sempre usar nomes qualificados, o código Nim é ``de std/math import nil``. Então você pode chamar ``math.sin () ``, ``math.cos ()``, etc. O equivalente em Python é ``import math``."

#: Nim.wiki/Nim-for-Python-Programmers.md:158
msgid ""
"It is generally safe to import all names in Nim because the compiler will not actually compile any unused functions (so there's no overhead). Furthermore, since Nim is statically typed, it can usually distinguish between the two imported functions with the same names based on the types of the arguments they are called with. In the "
"rare cases where the types are the same, you can still fully qualify the name to disambiguate."
msgstr ""
"Geralmente, é seguro importar todos os nomes no Nim porque o compilador não compilará nenhuma função não utilizada (portanto, não há sobrecarga). Além disso, como o Nim é digitado estaticamente, ele geralmente pode distinguir entre as duas funções importadas com os mesmos nomes com base nos tipos de argumentos com os quais são "
"chamadas. Nos raros casos em que os tipos são iguais, você ainda pode qualificar totalmente o nome para desambiguar."

#: Nim.wiki/Nim-for-Python-Programmers.md:160
msgid "The prefix `std/` enforces that the module is imported from the standard library. If a Nimble package has a module with the same name, the compiler can resolve the ambiguity and it is explicit in the code."
msgstr "O prefixo `std/` impõe que o módulo seja importado da biblioteca padrão. Se um pacote Nimble tiver um módulo com o mesmo nome, o compilador pode resolver a ambigüidade e isso está explícito no código."

#: Nim.wiki/Nim-for-Python-Programmers.md:162
msgid "Local modules and Nimble modules do not need `std/` prefix."
msgstr "Módulos locais e módulos Nimble não precisam do prefixo `std/`."

#: Nim.wiki/Nim-for-Python-Programmers.md:164
msgid "Python and Nim share these import statements:"
msgstr "Python e Nim compartilham essas declarações de importação:"

#: Nim.wiki/Nim-for-Python-Programmers.md:166
msgid ""
"# Python and Nim\n"
"import foo, bar, baz\n"
"\n"
"import foo\n"
"import bar\n"
"import baz"
msgstr ""
"# Python e Nim\n"
"importar comida, bar, baz\n"
"\n"
"importar alimentos\n"
"barra de importação\n"
"baz de importação"

#: Nim.wiki/Nim-for-Python-Programmers.md:167
msgid "Alternative syntaxes:"
msgstr "Sintaxes alternativas:"

#: Nim.wiki/Nim-for-Python-Programmers.md:169
msgid ""
"# Python\n"
"import foo, \\\n"
"       bar, \\\n"
"       baz"
msgstr ""
"# Python\n"
"importar alimentos,\\\n"
" barra,\\\n"
" baz"

#: Nim.wiki/Nim-for-Python-Programmers.md:170
msgid ""
"# Nim\n"
"import foo,\n"
"       bar,\n"
"       baz\n"
"\n"
"# Useful for small diffs when adding/removing imports\n"
"import\n"
"  foo,\n"
"  bar,\n"
"  baz\n"
"\n"
"import \n"
"  foo, bar, baz,\n"
"  more, imports"
msgstr ""
"# Nim\n"
"alimentos importados,\n"
" barra,\n"
" baz\n"
"\n"
"# Útil para pequenas diferenças ao adicionar/remover importações\n"
"importação\n"
" comida,\n"
" barra,\n"
" baz\n"
"\n"
"importação \n"
" comida, bar, baz,\n"
" mais, importações"

#: Nim.wiki/Nim-for-Python-Programmers.md:171
msgid "The variant with one `import` statement per line is common in Python and Nim, but in Nim the form `import foo, bar, baz` is also seen often."
msgstr "A variante com uma instrução `import` por linha é comum em Python e Nim, mas em Nim a forma `import foo, bar, baz` também é vista com frequência."

#: Nim.wiki/Nim-for-Python-Programmers.md:173
msgid "More examples:"
msgstr "Mais exemplos:"

#: Nim.wiki/Nim-for-Python-Programmers.md:175
msgid ""
"## This is documentation for the module.\n"
"#  This is a comment.\n"
"include prelude\n"
"import std/sugar as stevia\n"
"from std/math import nil\n"
"from std/with as what import nil"
msgstr ""
"## Esta é a documentação do módulo.\n"
"# Isso é um comentário.\n"
"incluir prelúdio\n"
"importar std/açúcar como estévia\n"
"de std/math import nil\n"
"de std/with como o que importa nil"

#: Nim.wiki/Nim-for-Python-Programmers.md:176
msgid "Programatically"
msgstr "Programaticamente"

#: Nim.wiki/Nim-for-Python-Programmers.md:177
msgid "__import__(\"math\")"
msgstr "__import__ (“matemática”)"

#: Nim.wiki/Nim-for-Python-Programmers.md:180
msgid ""
"template imports(s) = import s\n"
"imports math"
msgstr ""
"importações (s) de modelo = importação s\n"
"importa matemática"

#: Nim.wiki/Nim-for-Python-Programmers.md:181
msgid "Code without imports"
msgstr "Código sem importações"

#: Nim.wiki/Nim-for-Python-Programmers.md:182
msgid "Sometimes in the wild you may see code samples or files **without** the imports but they somehow work anyway. The reason is that Nim can use `import` from the compile command, or from a `.nims` file:"
msgstr "Às vezes, na natureza, você pode ver amostras de código ou arquivos **sem** as importações, mas eles de alguma forma funcionam de qualquer maneira. O motivo é que Nim pode usar `import` do comando compile ou de um arquivo `.nims`:"

#: Nim.wiki/Nim-for-Python-Programmers.md:186
msgid "`nim c --import:sugar file.nim`"
msgstr "`nim c —importação:arquivo de açúcar.nim`"

#: Nim.wiki/Nim-for-Python-Programmers.md:189
msgid "`nim c --import:folder/mymodule file.nim`"
msgstr "`nim c —import:pasta/meu arquivo de módulo.nim`"

#: Nim.wiki/Nim-for-Python-Programmers.md:192
msgid "`nim js --import:strutils --include:mymodule file.nim`"
msgstr "`nim js —import:strutils —include:mymodule file.nim`"

#: Nim.wiki/Nim-for-Python-Programmers.md:196
msgid "Sometimes projects or quick code examples use this to save some typing. Thanks to Dead Code Elimination, if the imported symbols are not used they will not exist on the compiled output."
msgstr "Às vezes, projetos ou exemplos de código rápido usam isso para evitar a digitação. Graças ao Dead Code Elimination, se os símbolos importados não forem usados, eles não existirão na saída compilada."

#: Nim.wiki/Nim-for-Python-Programmers.md:198 Nim.wiki/Nim-for-Python-Programmers.md:271 Nim.wiki/Nim-for-Python-Programmers.md:309 Nim.wiki/Nim-for-Python-Programmers.md:356 Nim.wiki/Nim-for-Python-Programmers.md:422 Nim.wiki/Nim-for-Python-Programmers.md:735 Nim.wiki/Nim-for-Python-Programmers.md:984
msgid "See also:"
msgstr "Veja também:"

#: Nim.wiki/Nim-for-Python-Programmers.md:202
msgid "[Nim Command line switches](https://nim-lang.github.io/Nim/nimc.html#compiler-usage-command-line-switches) "
msgstr "[Interruptores de linha de comando Nim] (https://nim-lang.github.io/Nim/nimc.html#compiler-usage-command-line-switches) "

#: Nim.wiki/Nim-for-Python-Programmers.md:206
msgid "Prelude"
msgstr "Prelúdio"

#: Nim.wiki/Nim-for-Python-Programmers.md:207
msgid "Sometimes you may feel that Python has more symbols available by default without any `import` compared to Nim. To get a similar experience of having the basic data structures and most common imports ready so you can get coding right away, you can use [prelude](https://nim-lang.github.io/Nim/prelude.html):"
msgstr ""
"Às vezes, você pode achar que o Python tem mais símbolos disponíveis por padrão sem qualquer `importação` em comparação com o Nim. Para ter uma experiência semelhante de ter as estruturas básicas de dados e as importações mais comuns prontas para que você possa começar a codificar imediatamente, você pode usar [prelude] (https://"
"nim-lang.github.io/Nim/prelude.html):"

#: Nim.wiki/Nim-for-Python-Programmers.md:209
msgid ""
"include prelude\n"
"\n"
"echo now()             \n"
"echo getCurrentDir() \n"
"echo \"Hello $1\".format(\"World\")"
msgstr ""
"incluir prelúdio\n"
"\n"
"echo now () \n"
"echo getCurrentDir () \n"
"echo “Olá $1\".format (“Mundo”)"

#: Nim.wiki/Nim-for-Python-Programmers.md:210
msgid ""
"[prelude](https://nim-lang.github.io/Nim/prelude.html) is an\n"
"[`include` file](https://nim-lang.github.io/Nim/manual.html#modules-include-statement) \n"
"that simply imports common modules for your convenience, to save some typing.\n"
"[prelude](https://nim-lang.github.io/Nim/prelude.html) works for JavaScript target too."
msgstr ""
"[prelúdio] (https://nim-lang.github.io/Nim/prelude.html) é um\n"
"[`include` arquivo] (https://nim-lang.github.io/Nim/manual.html#modules-include-statement) \n"
"que simplesmente importa módulos comuns para sua conveniência, para evitar a digitação.\n"
"[prelúdio] (https://nim-lang.github.io/Nim/prelude.html) também funciona para destinos em JavaScript."

#: Nim.wiki/Nim-for-Python-Programmers.md:212
msgid "Where Symbols come from?"
msgstr "De onde vêm os símbolos?"

#: Nim.wiki/Nim-for-Python-Programmers.md:215
msgid "If symbols are unqualified, how do you know where symbols come from?"
msgstr "Se os símbolos não são qualificados, como você sabe de onde vêm os símbolos?"

#: Nim.wiki/Nim-for-Python-Programmers.md:219
msgid "Given `foo()` is a symbol:"
msgstr "Dado que `foo () `é um símbolo:"

#: Nim.wiki/Nim-for-Python-Programmers.md:223
msgid "Nim: you typically have `foo()`, [with UFCS support](https://en.wikipedia.org/wiki/Uniform_Function_Call_Syntax#Nim_programming_language).  "
msgstr "Nota: você normalmente tem `foo () `, [com suporte do UFCS] (https://en.wikipedia.org/wiki/Uniform_Function_Call_Syntax#Nim_programming_language).  "

#: Nim.wiki/Nim-for-Python-Programmers.md:226
msgid "Python: you typically have `object.foo()` rather than `module.foo()`, no UFCS."
msgstr "Python: você normalmente tem `object.foo () `em vez de `module.foo ()`, sem UFCS."

#: Nim.wiki/Nim-for-Python-Programmers.md:230
msgid ""
"Typically the [Editor/IDE](https://marketplace.visualstudio.com/items?itemName=kosz78.nim) \n"
"should hint where the symbols come from, like in any other programming language:"
msgstr ""
"Normalmente, o [Editor/IDE] (https://marketplace.visualstudio.com/items?itemName=kosz78.nim) \n"
"deve sugerir de onde vêm os símbolos, como em qualquer outra linguagem de programação:"

#: Nim.wiki/Nim-for-Python-Programmers.md:232
msgid "![](https://raw.githubusercontent.com/pragmagic/vscode-nim/master/images/nim_vscode_output_demo.gif)"
msgstr "! [] (https://raw.githubusercontent.com/pragmagic/vscode-nim/master/images/nim_vscode_output_demo.gif)"

#: Nim.wiki/Nim-for-Python-Programmers.md:234
msgid "Nim comes built-in with [NimSuggest](https://nim-lang.org/docs/nimsuggest.html) for Editor/IDE integrations."
msgstr "O Nim vem integrado com o [NimSuggest] (https://nim-lang.org/docs/nimsuggest.html) para integrações de editor/IDE."

#: Nim.wiki/Nim-for-Python-Programmers.md:236
msgid "Contrary to Python, Nim's type system has all the information about all of the symbols:"
msgstr "Ao contrário do Python, o sistema de tipos de Nim tem todas as informações sobre todos os símbolos:"

#: Nim.wiki/Nim-for-Python-Programmers.md:238
msgid ""
"import std/macros\n"
"macro findSym(thing: typed) = echo thing.getType.lineInfo\n"
"\n"
"findSym:\n"
"  echo  # Where echo comes from?."
msgstr ""
"importar std/macros\n"
"macro FindSym (coisa: digitada) = echo thing.getType.lineInfo\n"
"\n"
"Encontre Sym:\n"
" echo # De onde vem o eco?."

#: Nim.wiki/Nim-for-Python-Programmers.md:239
msgid "`echo` comes from:"
msgstr "`echo` vem de:"

#: Nim.wiki/Nim-for-Python-Programmers.md:241
msgid "lib/system.nim(1929, 12)"
msgstr "lib/system.nim (1929, 12)"

#: Nim.wiki/Nim-for-Python-Programmers.md:242
msgid "When learning Nim, or for quick prototyping, it is okay to use the symbols fully qualified. Doing so produces no errors, but idiomatic Nim avoids this."
msgstr "Ao aprender Nim ou para prototipagem rápida, não há problema em usar os símbolos totalmente qualificados. Fazer isso não produz erros, mas o idiomático Nim evita isso."

#: Nim.wiki/Nim-for-Python-Programmers.md:244
msgid "Exports"
msgstr "Exportações"

#: Nim.wiki/Nim-for-Python-Programmers.md:245
msgid "In Python all symbols in the module are visible and mutable from modules that import it, including symbols that should not be used or mutated outside the module."
msgstr "Em Python, todos os símbolos no módulo são visíveis e mutáveis dos módulos que o importam, incluindo símbolos que não devem ser usados ou alterados fora do módulo."

#: Nim.wiki/Nim-for-Python-Programmers.md:247
msgid "In Nim everything is private by default and therefore is not visible from other modules. To make symbols public and visible in other modules, you have to use the asterisk `*`:"
msgstr "No Nim, tudo é privado por padrão e, portanto, não é visível em outros módulos. Para tornar os símbolos públicos e visíveis em outros módulos, você precisa usar o asterisco `*`:"

#: Nim.wiki/Nim-for-Python-Programmers.md:249
msgid ""
"let variable* = 42\n"
"const constant* = 0.0\n"
"proc someFunction*() = discard\n"
"template someTemplate*() = discard\n"
"type Platypus* = object\n"
"  fluffyness*: int"
msgstr ""
"variável deixada* = 42\n"
"constante constante* = 0,0\n"
"proc someFunction* () = descartar\n"
"template SomeTemplate* () = descartar\n"
"tipo Platypus* = objeto\n"
" fofinidade*: int"

#: Nim.wiki/Nim-for-Python-Programmers.md:250
msgid ""
"The asterisk not only makes the symbol visible to the outside world, \n"
"the symbol will also appear in the generated documentation (`nim doc`). \n"
"When you import the module, the symbol will be automatically added to the namespace, \n"
"but private (not exported) symbols without `*` will not be visible. \n"
"The asterisk is like a __visual cue__ for humans. You can immediately understand what symbols are a part of the \"the public API\" just by looking at the module's source code.\n"
"The asterisk `*` is pronounced as \"star\"."
msgstr ""
"O asterisco não só torna o símbolo visível para o mundo exterior, \n"
"o símbolo também aparecerá na documentação gerada (`nim doc`). \n"
"Quando você importa o módulo, o símbolo será automaticamente adicionado ao namespace, \n"
"mas símbolos privados (não exportados) sem `*` não serão visíveis. \n"
"O asterisco é como uma __dica visual__ para humanos. Você pode entender imediatamente quais símbolos fazem parte da “API pública” apenas examinando o código-fonte do módulo.\n"
"O asterisco `*` é pronunciado como “estrela”."

#: Nim.wiki/Nim-for-Python-Programmers.md:252
msgid "For more information, read: https://narimiran.github.io/2019/07/01/nim-import.html"
msgstr "Para obter mais informações, leia: https://narimiran.github.io/2019/07/01/nim-import.html"

#: Nim.wiki/Nim-for-Python-Programmers.md:254
msgid "try/import/except"
msgstr "tente/importação/exceto"

#: Nim.wiki/Nim-for-Python-Programmers.md:255
msgid "In Python, imports are a runtime operation and can fail. It is a fairly common pattern that platform-dependent imports are placed inside a try block, and an alternative or fallback inside the except:"
msgstr "Em Python, as importações são uma operação em tempo de execução e podem falhar. É um padrão bastante comum que as importações dependentes da plataforma sejam colocadas dentro de um bloco de teste e uma alternativa ou alternativa dentro do bloco, exceto:"

#: Nim.wiki/Nim-for-Python-Programmers.md:257
msgid ""
"try:\n"
"    import module\n"
"except ImportError:\n"
"    import othermodule as module\n"
"\n"
"try:\n"
"    from module import some_func\n"
"except ImportError:\n"
"    # Fallback implementation\n"
"    def somefunc():\n"
"        return some_value  "
msgstr ""
"tente:\n"
" módulo de importação\n"
"exceto ImporError:\n"
" importar outro módulo como módulo\n"
"\n"
"tente:\n"
" do módulo import some_func\n"
"exceto ImporError:\n"
" # Implementação alternativa\n"
" def somefunc ():\n"
" retornar alguma_valor  "

#: Nim.wiki/Nim-for-Python-Programmers.md:258
msgid "Nim resolves all imports at compile-time, so something like an `ImportError` does not exist. There's no need to handle import errors at runtime."
msgstr "O Nim resolve todas as importações em tempo de compilação, então algo como um `importError` não existe. Não há necessidade de lidar com erros de importação em tempo de execução."

#: Nim.wiki/Nim-for-Python-Programmers.md:260
msgid "Arrays"
msgstr "Matrizes"

#: Nim.wiki/Nim-for-Python-Programmers.md:261
msgid "Arrays in Nim are fixed size, start at index `0`, and must contain elements of the same type."
msgstr "As matrizes em Nim são de tamanho fixo, começam no índice `0` e devem conter elementos do mesmo tipo."

#: Nim.wiki/Nim-for-Python-Programmers.md:263
msgid "When passing an array to a function in Nim, the argument is an immutable reference. Nim will include run-time checks on the bounds of the arrays."
msgstr "Ao passar uma matriz para uma função em Nim, o argumento é uma referência imutável. O Nim incluirá verificações em tempo de execução nos limites das matrizes."

#: Nim.wiki/Nim-for-Python-Programmers.md:265
msgid ""
"You can use an [`openarray`](https://nim-lang.github.io/Nim/manual.html#types-open-arrays) \n"
"to accept an array of any size on the function arguments,\n"
"and you can use `low(your_array)` and `high(your_array)` to query the bounds of the array."
msgstr ""
"Você pode usar um [`openarray`] (https://nim-lang.github.io/Nim/manual.html#types-open-arrays) \n"
"para aceitar uma matriz de qualquer tamanho nos argumentos da função,\n"
"e você pode usar `low (your_array) `e `high (your_array)` para consultar os limites da matriz."

#: Nim.wiki/Nim-for-Python-Programmers.md:267
msgid "Nim `string` is compatible with `openArray[char]` to avoid unneeded copies for optimization, and `char` is compatible with `int`. Therefore `string` manipulation can be done with math in-place transparently. A function that takes `openArray[char]` accepts `\"abcd\"` *and* `['a', 'b', 'c', 'd']`."
msgstr "Nim `string` é compatível com `OpenArray [char] `para evitar cópias desnecessárias para otimização, e `char` é compatível com `int`. Portanto, a manipulação de `string` pode ser feita com a matemática no local de forma transparente. Uma função que usa `openArray [char] `aceita `\"abcd\"` *e*` ['a', 'b', 'c', 'd'] `."

#: Nim.wiki/Nim-for-Python-Programmers.md:269
msgid "Array contents are always contiguous in memory, as are arrays of arrays."
msgstr "O conteúdo da matriz é sempre contíguo na memória, assim como as matrizes de matrizes."

#: Nim.wiki/Nim-for-Python-Programmers.md:275
msgid "[Views](https://nim-lang.github.io/Nim/manual_experimental.html#view-types)"
msgstr "[Visualizações] (https://nim-lang.github.io/Nim/manual_experimental.html#view-types)"

#: Nim.wiki/Nim-for-Python-Programmers.md:279
msgid "Data Type Sizes"
msgstr "Tamanhos dos tipos de dados"

#: Nim.wiki/Nim-for-Python-Programmers.md:282
msgid "Whats the size of the different data types?."
msgstr "Qual é o tamanho dos diferentes tipos de dados?."

#: Nim.wiki/Nim-for-Python-Programmers.md:286
msgid ""
"import std/json\n"
"\n"
"type Foo = object            \n"
"type Bar = enum true, false  \n"
"\n"
"# (Weird spacing intended)\n"
"assert sizeOf( Foo )        == 1\n"
"assert sizeOf( Bar )        == 1\n"
"assert sizeOf( bool )       == 1\n"
"assert sizeOf( {true} )     == 1\n"
"assert sizeOf( [true] )     == 1\n"
"assert sizeOf( (true) )     == 1\n"
"assert sizeOf( int8 )       == 1\n"
"\n"
"assert sizeOf( {'k': 'v'} ) == 2\n"
"assert sizeOf( int16 )      == 2\n"
"\n"
"assert sizeOf( int32 )      == 4\n"
"assert sizeOf( float32 )    == 4\n"
"\n"
"assert sizeOf( int )        == 8\n"
"assert sizeOf( float )      == 8\n"
"assert sizeOf( @[true] )    == 8\n"
"assert sizeOf( %*{} )       == 8\n"
"assert sizeOf( pointer )    == 8"
msgstr ""
"importar std/json\n"
"\n"
"tipo Foo = objeto \n"
"tipo Bar = enum verdadeiro, falso \n"
"\n"
"# (Espaçamento estranho pretendido)\n"
"assert sizeOf (Foo) == 1\n"
"assert sizeOf (Bar) == 1\n"
"assert sizeOf (bool) = 1\n"
"assert sizeOf ({true}) == 1\n"
"assert sizeOf ([true]) == 1\n"
"assert sizeOf (true)) == 1\n"
"assert sizeOf (int8) == 1\n"
"\n"
"assert sizeOf ({'k': 'v'}) == 2\n"
"assert sizeOf (int16) == 2\n"
"\n"
"assert sizeOf (int32) == 4\n"
"assert sizeOf (float32) == 4\n"
"\n"
"assert sizeOf (int) == 8\n"
"assert sizeOf (float) == 8\n"
"assert sizeOf (@ [true]) == 8\n"
"assert sizeOf (%* {}) == 8\n"
"assert sizeOf (ponteiro) == 8"

#: Nim.wiki/Nim-for-Python-Programmers.md:287
msgid "This is only an approximation for the empty primitives on 64-bit."
msgstr "Essa é apenas uma aproximação para as primitivas vazias em 64 bits."

#: Nim.wiki/Nim-for-Python-Programmers.md:289
msgid "Objects"
msgstr "Objetos"

#: Nim.wiki/Nim-for-Python-Programmers.md:290
msgid ""
"Objects in Nim behave quite differently from classes in Python.\n"
"Objects support inheritance and OOP. Classes are named types in Nim.\n"
"Functions (procs) are free floating functions, not bound to objects \n"
"(however, you can use them in a very similar way to Python).\n"
"You can call a function on objects with the `object.function()` syntax as well as `function(object)`; [these are entirely equivalent](https://en.wikipedia.org/wiki/Uniform_Function_Call_Syntax).\n"
"Nim does not have an implicit `self` nor `this`.\n"
"It is best practice to put all your types near the top of the file, but this is not mandatory."
msgstr ""
"Objetos em Nim se comportam de forma bem diferente das classes em Python.\n"
"Os objetos suportam herança e OOP. As classes são denominadas tipos em Nim.\n"
"Funções (procs) são funções flutuantes livres, não vinculadas a objetos \n"
"(no entanto, você pode usá-los de uma forma muito semelhante ao Python).\n"
"Você pode chamar uma função em objetos com a sintaxe `object.function () `, bem como `function (object)`; [estes são totalmente equivalentes] (https://en.wikipedia.org/wiki/Uniform_Function_Call_Syntax).\n"
"Nim não tem um `eu` implícito nem `isso`.\n"
"É uma boa prática colocar todos os tipos no topo do arquivo, mas isso não é obrigatório."

#: Nim.wiki/Nim-for-Python-Programmers.md:292
msgid "A way to imagine this is that **procs get \"glued\" to the types of their arguments at compile-time**, and then you can use them at runtime as if they were Python classes and methods."
msgstr "Uma forma de imaginar isso é que **procs ficam “grudados” nos tipos de seus argumentos em tempo de compilação** e, em seguida, você pode usá-los em tempo de execução como se fossem classes e métodos do Python."

#: Nim.wiki/Nim-for-Python-Programmers.md:294
msgid "From Python to Nim, *as minimal as possible* example:"
msgstr "Do Python ao Nim, *o mínimo possível* exemplo:"

#: Nim.wiki/Nim-for-Python-Programmers.md:296
msgid ""
"class Kitten:\n"
"    \"\"\" Documentation Here \"\"\"\n"
"\n"
"    def purr(self):\n"
"        print(\"Purr Purr\")\n"
"\n"
"Kitten().purr()"
msgstr ""
"classe Kitten:\n"
" “\"” Documentação aqui “\"”\n"
"\n"
" def purr (self):\n"
" print (“Purr Purr”)\n"
"\n"
"Gatinho () .purr ()"

#: Nim.wiki/Nim-for-Python-Programmers.md:299
msgid ""
"type Kitten = object  ## Documentation Here\n"
"proc purr(self: Kitten) = echo \"Purr Purr\"\n"
"Kitten().purr()"
msgstr ""
"digite Kitten = object ## Documentação aqui\n"
"proc purr (self: Kitten) = echo “Purr Purr”\n"
"Gatinho () .purr ()"

#: Nim.wiki/Nim-for-Python-Programmers.md:300
msgid "Minimal inheritance example:"
msgstr "Exemplo de herança mínima:"

#: Nim.wiki/Nim-for-Python-Programmers.md:302
msgid ""
"type Animal = object of RootObj\n"
"type Kitten = object of Animal\n"
"assert Kitten is Animal"
msgstr ""
"tipo Animal = objeto de RootObj\n"
"tipo Kitten = objeto de Animal\n"
"afirme que o gatinho é um animal"

#: Nim.wiki/Nim-for-Python-Programmers.md:303
msgid "Python-like object orientation examples:"
msgstr "Exemplos de orientação de objetos semelhantes aos do Python:"

#: Nim.wiki/Nim-for-Python-Programmers.md:305
msgid ""
"type Animal = ref object of RootObj ## Animal base object.\n"
"  age: int                          \n"
"  name: string                      ## Attributes of base object.\n"
"\n"
"type Cat = ref object of Animal     ## Cat inherited object.\n"
"  playfulness: float                ## Attributes of inherited object.\n"
"\n"
"func increase_age(self: Cat) =\n"
"  self.age.inc()                    # Cat object function, access and *modify* object.\n"
"\n"
"var kitten = Cat(name: \"Tom\")       # Cat object instance.\n"
"kitten.increase_age()               # Cat object function used.\n"
"\n"
"assert kitten.name == \"Tom\"         # Assert on Cat object.\n"
"assert kitten.age == 1"
msgstr ""
"type Animal = objeto de referência do RootObj ## Objeto base animal.\n"
" página: int \n"
" nome: string ## Atributos do objeto base.\n"
"\n"
"type Cat = objeto de referência do Animal ## Objeto herdado do gato.\n"
" brincadeira: float ## Atributos do objeto herdado.\n"
"\n"
"func increase_age (self: Cat) =\n"
" self.age.inc () # Função do objeto Cat, acesso e objeto *modificar*.\n"
"\n"
"var kitten = Cat (nome: “Tom”) # Instância do objeto Cat.\n"
"kitten.increase_age () # Função do objeto Cat usada.\n"
"\n"
"assert kitten.name == “Tom” # Afirmar no objeto Cat.\n"
"afirmar kitten.age = 1"

#: Nim.wiki/Nim-for-Python-Programmers.md:306
msgid "Inheritance example:"
msgstr "Exemplo de herança:"

#: Nim.wiki/Nim-for-Python-Programmers.md:308
msgid ""
"type\n"
"  LUCA        = ref object of RootObj\n"
"  Archea      = ref object of LUCA\n"
"  Prokaryota  = ref object of Archea\n"
"  Eukaryota   = ref object of Prokaryota\n"
"  Animalia    = ref object of Eukaryota\n"
"  Chordata    = ref object of Animalia\n"
"  Mammalia    = ref object of Chordata\n"
"  Primates    = ref object of Mammalia\n"
"  Haplorhini  = ref object of Primates\n"
"  Simiiformes = ref object of Haplorhini\n"
"  Hominidae   = ref object of Simiiformes\n"
"  Homininae   = ref object of Hominidae\n"
"  Hominini    = ref object of Homininae\n"
"  Homo        = ref object of Hominini\n"
"  Homosapiens = ref object of Homo\n"
"\n"
"assert Homosapiens() is LUCA\n"
"assert LUCA() isnot Homosapiens\n"
"assert sizeOf(Homosapiens) == sizeOf(LUCA)\n"
"let human = Homosapiens()\n"
"assert human is Homosapiens"
msgstr ""
"tipo\n"
" LUCA = objeto de referência do RootObj\n"
" Archea = objeto ref de LUCA\n"
" Prokaryota = objeto ref de Archea\n"
" Eukaryota = objeto ref de Prokaryota\n"
" Animalia = objeto de referência de Eukaryota\n"
" Chordata = objeto ref de Animalia\n"
" Mammalia = objeto de referência de Chordata\n"
" Primatas = objeto de referência de Mammalia\n"
" Haplorhini = objeto ref de primatas\n"
" Simiiformes = objeto ref de Haplorhini\n"
" Hominidae = objeto de referência de Simiiformes\n"
" Homininae = objeto de referência de Hominidae\n"
" Hominini = objeto ref de Homininae\n"
" Homo = objeto ref de Hominini\n"
" Homosapiens = objeto de referência do Homo\n"
"\n"
"afirmar que Homosapiens () é LUCA\n"
"afirmar que LUCA () não é Homo sapiens\n"
"assert sizeOf (Homosapiens) == sizeOf (LUCA)\n"
"seja humano = Homosapiens ()\n"
"afirmar que o ser humano é Homosapiens"

#: Nim.wiki/Nim-for-Python-Programmers.md:313
msgid "[Dynamic Typing via metaprogramming](https://github.com/Carpall/nobject#here-a-simple-object-for-allowing-dynamic-typing-in-nim)"
msgstr "[Digitação dinâmica via metaprogramação] (https://github.com/Carpall/nobject#here-a-simple-object-for-allowing-dynamic-typing-in-nim)"

#: Nim.wiki/Nim-for-Python-Programmers.md:317
msgid "`self.__init__()`"
msgstr "`eu. __init__ () `"

#: Nim.wiki/Nim-for-Python-Programmers.md:318
msgid "After the Cat example you are probably wondering how to do `def __init__(self, arg):`."
msgstr "Depois do exemplo do Cat, você provavelmente está se perguntando como fazer `def __init__ (self, arg) :`."

#: Nim.wiki/Nim-for-Python-Programmers.md:320
msgid "Python `__init__()` is Nim `newObject()` or `initObject()`. Lets make an `__init__()` for the Cat:"
msgstr "Python `__init__ () `é Nim `newObject ()` ou `initObject () `. Vamos fazer um `__init__ () `para o gato:"

#: Nim.wiki/Nim-for-Python-Programmers.md:322
msgid ""
"type Cat = object                # Cat object.\n"
"  age: int                          \n"
"  name: string                   # Attributes of Cat object.\n"
"\n"
"func initCat(age = 2): Cat =     # Cat.__init__(self, age=2)                    \n"
"  result.age = age               # self.age = age         \n"
"  result.name = \"adopt_me\"       # self.name = \"adopt_me\" \n"
"\n"
"var kitten = initCat()            # Cat object instance.\n"
"\n"
"assert kitten.name == \"adopt_me\" # Assert on Cat object.\n"
"assert kitten.age == 2"
msgstr ""
"digite Cat = objeto # Objeto gato.\n"
" página: int \n"
" nome: string # Atributos do objeto Cat.\n"
"\n"
"função initCat (idade = 2): Cat = # Cat. __init__ (eu, idade=2) \n"
" resultado.idade = idade # self.idade = idade \n"
" result.name = “adopt_me” # self.name = “adopt_me” \n"
"\n"
"var kitten = initCat () # instância do objeto Cat.\n"
"\n"
"assert kitten.name == “adopt_me” # Assert no objeto Cat.\n"
"afirmar kitten.age = 2"

#: Nim.wiki/Nim-for-Python-Programmers.md:323
msgid ""
"Naming is a convention and best practice. When you want init for `Foo` just make `newFoo()` or `initFoo()`.\n"
"As you may notice `initCat` is just a function that returns a `Cat`."
msgstr ""
"A nomeação é uma convenção e uma boa prática. Quando você quiser init para `Foo`, basta criar `newFoo () `ou `initFoo ()`.\n"
"Como você pode notar, `initCat` é apenas uma função que retorna um `Cat`."

#: Nim.wiki/Nim-for-Python-Programmers.md:327
msgid "`initFoo()` for `object`."
msgstr "`initFoo () `para `objeto`."

#: Nim.wiki/Nim-for-Python-Programmers.md:330
msgid "`newFoo()` for `ref object`."
msgstr "`newFoo () `para `objeto ref`."

#: Nim.wiki/Nim-for-Python-Programmers.md:334
msgid "[Read the documentation for Naming things following conventions and best practices.](https://nim-lang.org/docs/apis.html)"
msgstr "[Leia a documentação para nomear coisas seguindo as convenções e as melhores práticas.] (https://nim-lang.org/docs/apis.html)"

#: Nim.wiki/Nim-for-Python-Programmers.md:336
msgid "Object Attribute Default Values"
msgstr "Valores padrão do atributo do objeto"

#: Nim.wiki/Nim-for-Python-Programmers.md:337
msgid "The object constructor is also the way to set custom default values to the attributes of your objects:"
msgstr "O construtor de objetos também é a forma de definir valores padrão personalizados para os atributos de seus objetos:"

#: Nim.wiki/Nim-for-Python-Programmers.md:339
msgid ""
"type Cat = object\n"
"  age: int                 # AutoInitialized to 0\n"
"  name: string             # AutoInitialized to \"\"\n"
"  playfulness: float       # AutoInitialized to 0.0\n"
"  sleeping: bool           # AutoInitialized to false \n"
"func initCat(): Cat =    \n"
"  result.age = 1           # Set default value to 1\n"
"  result.name = \"Bastet\"   # Set default value to \"Bastet\"\n"
"  result.playfulness = 9.0 # Set default value to 9.0\n"
"  result.sleeping = true   # Set default value to true"
msgstr ""
"tipo Cat = objeto\n"
" Página: int # AutoInitialized to 0\n"
" nome: string # Inicializado automaticamente para “”\n"
" diversão: float # inicializado automaticamente para 0.0\n"
" dormindo: bool # Inicializado automaticamente para falso \n"
"função initCat (): Cat = \n"
" result.age = 1 # Defina o valor padrão como 1\n"
" result.name = “Bastet” # Defina o valor padrão para “Bastet”\n"
" result.playfulness = 9.0 # Defina o valor padrão para 9.0\n"
" result.sleeping = true # Defina o valor padrão como verdadeiro"

#: Nim.wiki/Nim-for-Python-Programmers.md:340
msgid "A more complete structure for a basic program can be something like:"
msgstr "Uma estrutura mais completa para um programa básico pode ser algo como:"

#: Nim.wiki/Nim-for-Python-Programmers.md:342
msgid ""
"## Simple application to  do Foo with the Bar.\n"
"\n"
"type\n"
"  Animal = ref object of RootObj \n"
"    age: int                          \n"
"    name: string                     \n"
"\n"
"  Cat = ref object of Animal\n"
"    playfulness: float   \n"
"\n"
"\n"
"func initCat(age = 2): Cat =   \n"
"  result.age = age            \n"
"  result.name = \"adopt_me\"     \n"
"\n"
"func increase_age(self: Cat) =\n"
"  self.age.inc()               \n"
"\n"
"proc main() =\n"
"  var kitten = Cat(name: \"Tom\")  \n"
"  kitten.increase_age()           \n"
"\n"
"  assert kitten.name == \"Tom\"      \n"
"  assert kitten.age == 1\n"
"\n"
"\n"
"when isMainModule:\n"
"  main()\n"
"\n"
"runnableExamples:\n"
"  echo \"Optionally some documentation code examples here\"\n"
"  assert 42 == 42\n"
msgstr ""
"## Aplicação simples para fazer Foo with the Bar.\n"
"\n"
"tipo\n"
" Animal = objeto de referência do RootObj \n"
" página: int \n"
" nome: string \n"
"\n"
" Gato = objeto de referência do Animal\n"
" brincadeira: flutuar \n"
"\n"
"\n"
"função initCat (idade = 2): Cat = \n"
" resultado.idade = idade \n"
" result.name = “adopt_me” \n"
"\n"
"func increase_age (self: Cat) =\n"
" self.age.inc () \n"
"\n"
"proc main () =\n"
" var kitten = Gato (nome: “Tom”) \n"
" gatinho. increase_age () \n"
"\n"
" assert kitten.name == “Tom” \n"
" afirmar kitten.age = 1\n"
"\n"
"\n"
"quando é MainModule:\n"
" principal ()\n"
"\n"
"Exemplos executáveis:\n"
" echo “Opcionalmente, alguns exemplos de código de documentação aqui”\n"
" afirmar 42 = 42\n"

#: Nim.wiki/Nim-for-Python-Programmers.md:343
msgid "Run-time Code Expansion"
msgstr "Expansão do código de execução"

#: Nim.wiki/Nim-for-Python-Programmers.md:344
msgid ""
"Python objects that *internally* use code generation are very very slow, \n"
"scaling with size. The more you use it the slower it runs. `dataclass`, `metaclass`, decorators, etc can be more than 25 ~ 50x slower than a normal `class`. [`pathlib.Path` and its methods can be more than 25 ~ 50x slower than a normal `str`](https://youtu.be/tFrh9hKMS6Y),\n"
"and defeats any optimization, including a `.pyc` file.\n"
"Cython does not have CTFE, so it does not help with this specifically."
msgstr ""
"Objetos Python que *internamente* usam geração de código são muito, muito lentos, \n"
"dimensionando com tamanho. Quanto mais você o usa, mais lento ele corre. `dataclass`, `metaclasse`, decoradores, etc. podem ser mais de 25 ~ 50x mais lentos do que uma `classe` normal. [`Pathlib.path` e seus métodos podem ser mais de 25 ~ 50x mais lentos do que um `str` normal] (https://youtu.be/tFrh9hKMS6Y),\n"
"e derrota qualquer otimização, incluindo um arquivo `.pyc`.\n"
"O Cython não tem CTFE, então isso não ajuda especificamente."

#: Nim.wiki/Nim-for-Python-Programmers.md:348
msgid "Nim code expansion is done at compile-time, making its code generation zero cost at run-time."
msgstr "A expansão do código Nim é feita em tempo de compilação, tornando sua geração de código zero em tempo de execução."

#: Nim.wiki/Nim-for-Python-Programmers.md:352
msgid "For example, you can see the result of ARC code expansion during compilation using `--expandArc`. This is how Nim does compile-time memory management (approximation):"
msgstr "Por exemplo, você pode ver o resultado da expansão do código ARC durante a compilação usando `—expandArc`. É assim que o Nim faz o gerenciamento de memória em tempo de compilação (aproximação):"

#: Nim.wiki/Nim-for-Python-Programmers.md:354
msgid "![](https://raw.githubusercontent.com/juancarlospaco/nim-presentation-slides/master/Nim_ARC.png)"
msgstr "! [] (https://raw.githubusercontent.com/juancarlospaco/nim-presentation-slides/master/Nim_ARC.png)"

#: Nim.wiki/Nim-for-Python-Programmers.md:360
msgid "[`macros.expandMacros` shows you the code expansion on the terminal during compilation](https://nim-lang.github.io/Nim/macros.html#expandMacros.m%2Ctyped)"
msgstr "[`Macros.expandMacros` mostra a expansão do código no terminal durante a compilação] (https://nim-lang.github.io/Nim/macros.html#expandMacros.m%2Ctyped)"

#: Nim.wiki/Nim-for-Python-Programmers.md:364
msgid "Unsafe Type Hints"
msgstr "Dicas de tipo inseguro"

#: Nim.wiki/Nim-for-Python-Programmers.md:365
msgid "Python \"type hints\" can be almost anything and are implicitly executed at run-time. Needless to say, this can be very unsafe:"
msgstr "As “dicas de tipo” do Python podem ser quase qualquer coisa e são executadas implicitamente em tempo de execução. Não é preciso dizer que isso pode ser muito inseguro:"

#: Nim.wiki/Nim-for-Python-Programmers.md:367
msgid ""
"$ cat example.py\n"
"class X: _: \"print('PWNED')\"  # os.system(\"rm -rf /folder \")\n"
"__import__(\"typing\").get_type_hints(X)\n"
"\n"
"$ python3 example.py\n"
"\n"
"'PWNED'\n"
"\n"
"$"
msgstr ""
"$ cat example.py\n"
"classe X: _: “print ('PWNED')” # os.system (“rm -rf /folder “)\n"
"__import__ (“digitação”) .get_type_hints (X)\n"
"\n"
"$ python3 example.py\n"
"\n"
"'PENED'\n"
"\n"
"$"

#: Nim.wiki/Nim-for-Python-Programmers.md:368
msgid "Nim types must be a valid Nim type, types are type checked at compile-time:"
msgstr "Os tipos de Nim devem ser válidos; os tipos são verificados no momento da compilação:"

#: Nim.wiki/Nim-for-Python-Programmers.md:370
msgid ""
"$ cat example.nim\n"
"type X = object\n"
"  a: \"echo('PWNED')\"\n"
"echo X()\n"
"\n"
"$ nim r example.nim    # Will not compile.\n"
"\n"
"Error: type expected, but got: \"echo('PWNED')\"\n"
"\n"
"$"
msgstr ""
"$ cat example.nim\n"
"tipo X = objeto\n"
" a: “echo ('PWNED')”\n"
"eco (X)\n"
"\n"
"$ nim r example.nim # Não será compilado.\n"
"\n"
"Erro: digite esperado, mas obteve: “echo ('PWNED')”\n"
"\n"
"$"

#: Nim.wiki/Nim-for-Python-Programmers.md:371
msgid "Another example"
msgstr "Outro exemplo"

#: Nim.wiki/Nim-for-Python-Programmers.md:373
msgid ""
"$ cat example.nim\n"
"var example: \"echo('PWNED')\"\n"
"echo example\n"
"\n"
"$ nim r example.nim    # Will not compile.\n"
"\n"
"Error: type expected, but got: \"echo('PWNED')\"\n"
"\n"
"$"
msgstr ""
"$ cat example.nim\n"
"exemplo de var: “echo ('PWNED')”\n"
"exemplo de eco\n"
"\n"
"$ nim r example.nim # Não será compilado.\n"
"\n"
"Erro: digite esperado, mas obteve: “echo ('PWNED')”\n"
"\n"
"$"

#: Nim.wiki/Nim-for-Python-Programmers.md:374
msgid "By-Value vs By-Reference"
msgstr "Por valor versus por referência"

#: Nim.wiki/Nim-for-Python-Programmers.md:377
msgid "Does Nim passes data around \"by value\" or \"by reference\"? It depends ..."
msgstr "O Nim transmite dados “por valor” ou “por referência”? Depende..."

#: Nim.wiki/Nim-for-Python-Programmers.md:381
msgid "The Nim compiler automatically determines whether a parameter is passed by-value or by-reference based on the parameter type's size. "
msgstr "O compilador Nim determina automaticamente se um parâmetro é passado por valor ou por referência com base no tamanho do tipo de parâmetro. "

#: Nim.wiki/Nim-for-Python-Programmers.md:383
msgid ""
"If a parameter must be passed by-value or by-reference (such as when interfacing with a C library), \n"
"then use the `{.bycopy.}` or `{.byref.}` pragmas."
msgstr ""
"Se um parâmetro precisar ser passado por valor ou por referência (como ao fazer interface com uma biblioteca C), \n"
"em seguida, use os pragmas `{.bycopy.}` ou `{.byref.}`."

#: Nim.wiki/Nim-for-Python-Programmers.md:385
msgid ""
"**Nim passes objects larger than `3 * sizeOf(int)` by reference for performance**,\n"
"but this is architecture and implementation defined.\n"
"So the following information is just an *approximation* for `x86_64`:"
msgstr ""
"**Nim passa objetos maiores que `3 * sizeOf (int) `por referência para desempenho**,\n"
"mas isso é arquitetura e implementação definidas.\n"
"Portanto, as informações a seguir são apenas uma *aproximação* para `x86_64`:"

#: Nim.wiki/Nim-for-Python-Programmers.md:390
msgid "Iff a \"by value\" symbol is big, then it is passed \"by reference\" automatically."
msgstr "Se um símbolo “por valor” for grande, ele será transmitido “por referência” automaticamente."

#: Nim.wiki/Nim-for-Python-Programmers.md:393
msgid "[You can disable this optimization using `{.bycopy.}` pragma on the symbol.](https://nim-lang.github.io/Nim/manual.html#foreign-function-interface-bycopy-pragma)"
msgstr "[Você pode desativar essa otimização usando o pragma `{.bycopy.}` no símbolo.] (https://nim-lang.github.io/Nim/manual.html#foreign-function-interface-bycopy-pragma)"

#: Nim.wiki/Nim-for-Python-Programmers.md:396
msgid "[The `{.byref.}` forces passing \"by reference\", the reverse of `{.bycopy.}`.](https://nim-lang.github.io/Nim/manual.html#foreign-function-interface-byref-pragma)"
msgstr "[O `{.byref.}` força a passagem “por referência”, o inverso de `{.bycopy.}`.] (https://nim-lang.github.io/Nim/manual.html#foreign-function-interface-byref-pragma)"

#: Nim.wiki/Nim-for-Python-Programmers.md:399
msgid "Nim `seq` is passed around \"by reference\" by default."
msgstr "Nim `seq` é passado “por referência” por padrão."

#: Nim.wiki/Nim-for-Python-Programmers.md:402
msgid "Nim `string` is [Copy-On-Write](https://en.wikipedia.org/wiki/Copy-on-write) COW (ARC/ORC)."
msgstr "Sua `string` é [Copy-On-Write] (https://en.wikipedia.org/wiki/Copy-on-write) COW (ARC/ORC)."

#: Nim.wiki/Nim-for-Python-Programmers.md:405
msgid "[Pointer Arithmetic can be performed with pointer.](https://en.wikipedia.org/wiki/Pointer%20arithmetic)"
msgstr "[A aritmética do ponteiro pode ser executada com o ponteiro.] (https://en.wikipedia.org/wiki/Pointer%20arithmetic)"

#: Nim.wiki/Nim-for-Python-Programmers.md:409
msgid "Ranges"
msgstr "Intervalos"

#: Nim.wiki/Nim-for-Python-Programmers.md:410
msgid "In Python, simple integer for loops use the `range` generator function. For the 1- and 2- argument forms of this function, nim's [`..` iterator](https://nim-lang.org/docs/system.html#...i%2CT%2CT) works almost the same way:"
msgstr "Em Python, um número inteiro simples para loops usa a função geradora `range`. Para as formas de argumento 1 e 2 dessa função, o [`..` iterator] (https://nim-lang.org/docs/system.html#...i%2CT%2CT) de nim funciona quase da mesma maneira:"

#: Nim.wiki/Nim-for-Python-Programmers.md:412
msgid ""
"for i in 0 .. 10:\n"
"  echo i  # Prints 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n"
"\n"
"for i in 5 .. 10:\n"
"  echo i  # Prints 5, 6, 7, 8, 9, 10"
msgstr ""
"para i em 0.. 10:\n"
" echo i # Imprime 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n"
"\n"
"para i em 5.1.10:\n"
" echo i # Imprime 5, 6, 7, 8, 9, 10"

#: Nim.wiki/Nim-for-Python-Programmers.md:413
msgid "Note that the `..` operator includes the end of the range, whereas Python's `range(a, b)` does not include `b`. If you prefer this behavior, use the [`..<` iterator](https://nim-lang.org/docs/system.html#..%3C.i%2CT%2CT) instead:"
msgstr "Observe que o operador `..` inclui o final do intervalo, enquanto o `range (a, b) `do Python não inclui `b`. Se você preferir esse comportamento, use o iterador [`.. <`] (https://nim-lang.org/docs/system.html#..%3C.i%2CT%2CT) em vez disso:"

#: Nim.wiki/Nim-for-Python-Programmers.md:415
msgid ""
"for i in 0 ..< 10:\n"
"  echo i  # Prints 0, 1, 2, 3, 4, 5, 6, 7, 8, 9"
msgstr ""
"para i em 0.. < 10:\n"
" echo i # Imprime 0, 1, 2, 3, 4, 5, 6, 7, 8, 9"

#: Nim.wiki/Nim-for-Python-Programmers.md:416
msgid ""
"Python `range()` also has an optional third parameter, \n"
"which is the value to increment by each step. This can be positive or negative. \n"
"If you need this behavior, use the [`countup`](https://nim-lang.org/docs/system.html#countup.i%2CT%2CT%2CPositive) or\n"
"[`countdown`](https://nim-lang.org/docs/system.html#countdown.i%2CT%2CT%2CPositive) iterators:"
msgstr ""
"O `range () `do Python também tem um terceiro parâmetro opcional, \n"
"que é o valor a ser incrementado em cada etapa. Isso pode ser positivo ou negativo. \n"
"Se você precisar desse comportamento, use o [`countup`] (https://nim-lang.org/docs/system.html#countup.i%2CT%2CT%2CPositive) ou\n"
"[`countdown`] (https://nim-lang.org/docs/system.html#countdown.i%2CT%2CT%2CPositive) iteradores:"

#: Nim.wiki/Nim-for-Python-Programmers.md:418
msgid ""
"for i in countup(1, 10, 2):\n"
"  echo i  # Prints 1, 3, 5, 7, 9\n"
"\n"
"for i in countdown(9, 0, 2):\n"
"  echo i  # Prints 9, 7, 5, 3, 1"
msgstr ""
"para i na contagem (1, 10, 2):\n"
" echo i # Imprime 1, 3, 5, 7, 9\n"
"\n"
"para i em contagem regressiva (9, 0, 2):\n"
" echo i # Imprime 9, 7, 5, 3, 1"

#: Nim.wiki/Nim-for-Python-Programmers.md:419
msgid "Convert from `range` to `seq`:"
msgstr "Converta de `range` para `seq`:"

#: Nim.wiki/Nim-for-Python-Programmers.md:421
msgid ""
"import sequtils\n"
"\n"
"const subrange = 0..9\n"
"const seqrange = toSeq(subrange)\n"
"assert seqrange is seq[int]"
msgstr ""
"sequências de importação\n"
"\n"
"subfaixa constante = 0,9\n"
"const seqrange = toSeq (subfaixa)\n"
"assert seqrange é seq [int]"

#: Nim.wiki/Nim-for-Python-Programmers.md:426
msgid "[enumerate](https://nim-lang.github.io/Nim/enumerate.html#enumerate.m%2CForLoopStmt)"
msgstr "[enumerar] (https://nim-lang.github.io/Nim/enumerate.html#enumerate.m%2CForLoopStmt)"

#: Nim.wiki/Nim-for-Python-Programmers.md:430
msgid "Slices"
msgstr "Fatias"

#: Nim.wiki/Nim-for-Python-Programmers.md:431
msgid "The syntax for slice ranges is different. Python's `a[x:y]` is Nim's `a[x ..< y]`."
msgstr "A sintaxe dos intervalos de fatias é diferente. `a [x:y] `do Python é `a [x.. < y]` de Nim."

#: Nim.wiki/Nim-for-Python-Programmers.md:433
msgid ""
"let variable = [1, 2, 3, 4]\n"
"assert variable[0 .. 0] == @[1]\n"
"assert variable[0 .. 1] == @[1, 2]\n"
"assert variable[0 ..< 2] == @[1, 2]\n"
"assert variable[0 .. 3] == @[1, 2, 3, 4]"
msgstr ""
"deixe variável = [1, 2, 3, 4]\n"
"variável de afirmação [0.. 0] == @ [1]\n"
"variável de afirmação [0,1] == @ [1, 2]\n"
"variável de afirmação [0.. < 2] == @ [1, 2]\n"
"variável assert [0.. 3] == @ [1, 2, 3, 4]"

#: Nim.wiki/Nim-for-Python-Programmers.md:434
msgid "Reverse Index Slices"
msgstr "Fatias de índice reverso"

#: Nim.wiki/Nim-for-Python-Programmers.md:435
msgid ""
"In Nim a reverse index or backwards index uses `^` with the number, like `^1`. Backwards indexes have a specific type `BackwardsIndex`,\n"
"and they can also be \"prepared\" at compile-time as a `const`:"
msgstr ""
"Em Nim, um índice reverso ou índice inverso usa `^` com o número, como `^1`. Os índices retroativos têm um tipo específico `backwardsIndex`,\n"
"e eles também podem ser “preparados” em tempo de compilação como um `const`:"

#: Nim.wiki/Nim-for-Python-Programmers.md:437
msgid ""
"const lastOne = ^1  # Compile-time\n"
"assert lastOne is BackwardsIndex\n"
"assert [1, 2, 3, 4, 5][2 .. lastOne] == @[3, 4, 5]\n"
"assert [1, 2, 3, 4, 5][2 .. ^1] == @[3, 4, 5]\n"
"var another = ^3    # Run-time\n"
"assert [1, 2, 3, 4, 5][0 .. another] == @[1, 2, 3]\n"
"assert [1, 2, 3, 4, 5][^3 .. ^1] == @[3, 4, 5]  # 2 Reverse index"
msgstr ""
"const LastOne = ^1 # Tempo de compilação\n"
"afirmar que o LastStone é BackwardsIndex\n"
"assert [1, 2, 3, 4, 5] [2.. último] == [3, 4, 5]\n"
"assert [1, 2, 3, 4, 5] [2.. ^1] == @ [3, 4, 5]\n"
"var another = ^3 # Tempo de execução\n"
"assert [1, 2, 3, 4, 5] [0.. outro] == @ [1, 2, 3]\n"
"assert [1, 2, 3, 4, 5] [^3.. ^1] == @ [3, 4, 5] # 2 Índice reverso"

#: Nim.wiki/Nim-for-Python-Programmers.md:438
msgid "Static Bounds-Check"
msgstr "Verificação de limites estáticos"

#: Nim.wiki/Nim-for-Python-Programmers.md:441
msgid "Nim has [static bounds-checking at compile-time.](https://en.wikipedia.org/wiki/Static_program_analysis)"
msgstr "Nim tem [verificação estática de limites em tempo de compilação.] (https://en.wikipedia.org/wiki/Static_program_analysis)"

#: Nim.wiki/Nim-for-Python-Programmers.md:445
msgid "Lets compare very simplified examples:"
msgstr "Vamos comparar exemplos muito simplificados:"

#: Nim.wiki/Nim-for-Python-Programmers.md:447
msgid "[0, 1, 2][9]  # No Index 9"
msgstr "[0, 1, 2] [9] # Sem índice 9"

#: Nim.wiki/Nim-for-Python-Programmers.md:448
msgid "This crashes at run-time because there is no index 9:"
msgstr "Isso falha em tempo de execução porque não há índice 9:"

#: Nim.wiki/Nim-for-Python-Programmers.md:450
msgid ""
"$ python3 example.py\n"
"Traceback (most recent call last):\n"
"  File \"example.py\", line 1, in <module>\n"
"    [0, 1, 2][9]\n"
"IndexError: list index out of range\n"
"\n"
"$"
msgstr ""
"$ python3 example.py\n"
"Rastreamento (última chamada mais recente):\n"
" Arquivo \"example.py “, linha 1, em <module>\n"
" [0, 1, 2] [9]\n"
"IndexError: lista o índice fora do intervalo\n"
"\n"
"$"

#: Nim.wiki/Nim-for-Python-Programmers.md:451
msgid "Let's see Nim:"
msgstr "Vamos ver Nim:"

#: Nim.wiki/Nim-for-Python-Programmers.md:453
msgid "discard [0, 1, 2][9] # No Index 9"
msgstr "descartar [0, 1, 2] [9] # Sem índice 9"

#: Nim.wiki/Nim-for-Python-Programmers.md:454 Nim.wiki/Nim-for-Python-Programmers.md:462
msgid "Compile and run:"
msgstr "Compile e execute:"

#: Nim.wiki/Nim-for-Python-Programmers.md:456
msgid ""
"$ nim compile --run example.nim\n"
"example.nim(1, 19) Warning: can prove: 9 > 2  [IndexCheck]\n"
"example.nim(1, 18) Error: index 9 not in 0..2 [0, 1, 2][9]\n"
"\n"
"$"
msgstr ""
"$ nim compile —run example.nim\n"
"example.nim (1, 19) Aviso: pode provar: 9 > 2 [indexCheck]\n"
"example.nim (1, 18) Erro: índice 9 não está em 0.. 2 [0, 1, 2] [9]\n"
"\n"
"$"

#: Nim.wiki/Nim-for-Python-Programmers.md:457
msgid "Nim checks at compile-time that `[0, 1, 2]` has no index `9`, because `9 > 2`. Therefore, it won't compile nor run."
msgstr "Nim verifica em tempo de compilação que `[0, 1, 2]` não tem índice `9`, porque `9 > 2`. Portanto, ele não será compilado nem executado."

#: Nim.wiki/Nim-for-Python-Programmers.md:459
msgid "This also works with Subrange. Let's say you have a integer variable that **must be positive**:"
msgstr "Isso também funciona com o Subrange. Digamos que você tenha uma variável inteira que **deva ser positiva**:"

#: Nim.wiki/Nim-for-Python-Programmers.md:461
msgid "let must_be_positive: Positive = -9"
msgstr "deixe must_be_positive: Positivo = -9"

#: Nim.wiki/Nim-for-Python-Programmers.md:464
msgid ""
"$ nim compile --run example.nim\n"
"example.nim(1, 34) Warning: can prove: 1 > -9 [IndexCheck]\n"
"example.nim(1, 34) Error: conversion from int literal -9 to Positive is invalid.\n"
"\n"
"$"
msgstr ""
"$ nim compile —run example.nim\n"
"example.nim (1, 34) Aviso: pode provar: 1 > -9 [indexCheck]\n"
"example.nim (1, 34) Erro: a conversão de int literal -9 para Positive é inválida.\n"
"\n"
"$"

#: Nim.wiki/Nim-for-Python-Programmers.md:465
msgid "Nim checks at compile-time that `must_be_positive` is not `Positive` because `1 > -9`. It won't compile nor run."
msgstr "Nim verifica em tempo de compilação se `must_be_positive` não é `Positivo` porque `1 > -9`. Ele não será compilado nem executado."

#: Nim.wiki/Nim-for-Python-Programmers.md:469
msgid ""
"var variable0: 5..8 = 5        # int range type, value must be between '5' and '8'.\n"
"variable0 = 8\n"
"variable0 = 7\n"
"assert not compiles(variable0 = 4)\n"
"assert not compiles(variable0 = 9)\n"
"assert not compiles(variable0 = 0)\n"
"assert not compiles(variable0 = -1)\n"
"assert not compiles(variable0 = -9)\n"
"\n"
"\n"
"var variable1: 3.3..7.5 = 3.3  # float range type, value must be between '3.3' and '7.5'.\n"
"variable1 = 7.5\n"
"variable1 = 5.5\n"
"assert not compiles(variable1 = 3.2)\n"
"assert not compiles(variable1 = 7.6)\n"
"assert not compiles(variable1 = 0.0)\n"
"assert not compiles(variable1 = -1.0)\n"
"assert not compiles(variable1 = -9.0)\n"
"\n"
"\n"
"var variable2: 'b'..'f' = 'b'  # char range type, value must be between 'b' and 'f'.\n"
"variable2 = 'f'\n"
"variable2 = 'c'\n"
"assert not compiles(variable2 = 'g')\n"
"assert not compiles(variable2 = 'a')\n"
"assert not compiles(variable2 = 'z')\n"
"assert not compiles(variable2 = '0')\n"
"assert not compiles(variable2 = '9')\n"
"\n"
"\n"
"var variable3: Positive = 1    # Positive type, value must be > 0.\n"
"variable3 = 1\n"
"variable3 = 999\n"
"assert not compiles(variable3 = 0)\n"
"assert not compiles(variable2 = -1)\n"
"assert not compiles(variable2 = -9)\n"
"\n"
"\n"
"var variable4: Natural = 0     # Natural type, value must be >= 0.\n"
"variable4 = 1\n"
"variable4 = 999\n"
"assert not compiles(variable4 = -1)\n"
"assert not compiles(variable4 = -9)"
msgstr ""
"var variable0:5.. 8 = 5 # int do tipo de intervalo, o valor deve estar entre '5' e '8'.\n"
"variável 0 = 8\n"
"variável 0 = 7\n"
"assert não compila (variável0 = 4)\n"
"assert não compila (variável0 = 9)\n"
"assert não compila (variável0 = 0)\n"
"assert não compila (variável0 = -1)\n"
"assert não compila (variável0 = -9)\n"
"\n"
"\n"
"var variable1:3.3.. 7.5 = 3.3 # tipo de faixa flutuante, o valor deve estar entre '3,3' e '7,5'.\n"
"variável1 = 7,5\n"
"variável1 = 5,5\n"
"assert não compila (variável1 = 3,2)\n"
"assert não compila (variável1 = 7,6)\n"
"assert não compila (variável1 = 0,0)\n"
"assert não compila (variável1 = -1,0)\n"
"assert não compila (variável1 = -9,0)\n"
"\n"
"\n"
"var variable2: 'b'.. ' f' = 'b' # tipo de intervalo de caracteres, o valor deve estar entre 'b' e 'f'.\n"
"variável2 = 'f'\n"
"variável2 = 'c'\n"
"assert não compila (variable2 = 'g')\n"
"assert não compila (variável2 = 'a')\n"
"assert não compila (variável2 = 'z')\n"
"assert não compila (variável2 = '0')\n"
"assert não compila (variável2 = '9')\n"
"\n"
"\n"
"var variable3: Positivo = 1 # Tipo positivo, o valor deve ser > 0.\n"
"variável 3 = 1\n"
"variável 3 = 999\n"
"assert não compila (variável3 = 0)\n"
"assert não compila (variável2 = -1)\n"
"assert não compila (variável2 = -9)\n"
"\n"
"\n"
"var variable4: Natural = 0 # Tipo natural, o valor deve ser >= 0.\n"
"variável 4 = 1\n"
"variável 4 = 999\n"
"assert não compila (variável4 = -1)\n"
"assert não compila (variável4 = -9)"

#: Nim.wiki/Nim-for-Python-Programmers.md:470
msgid "You can control this with `--staticBoundChecks:on` or `--staticBoundChecks:off`."
msgstr "Você pode controlar isso com `—staticBoundChecks:on` ou `—staticBoundChecks:off`."

#: Nim.wiki/Nim-for-Python-Programmers.md:472
msgid "With `--staticBoundChecks:off` it may raise an error at run-time like Python does."
msgstr "Com `—staticBoundChecks:off`, isso pode gerar um erro em tempo de execução, como o Python faz."

#: Nim.wiki/Nim-for-Python-Programmers.md:476
msgid "For better documentation see: https://nim-lang.github.io/Nim/drnim.html"
msgstr "Para obter uma documentação melhor, consulte: https://nim-lang.github.io/Nim/drnim.html"

#: Nim.wiki/Nim-for-Python-Programmers.md:480
msgid "Null Coalescing"
msgstr "Coalescência nula"

#: Nim.wiki/Nim-for-Python-Programmers.md:481
msgid "Python does not have a [null-coalescing operator](https://en.wikipedia.org/wiki/Null_coalescing_operator) (at the time of writing)."
msgstr "O Python não tem um [operador de coalescência nula] (https://en.wikipedia.org/wiki/Null_coalescing_operator) (no momento em que este artigo foi escrito)."

#: Nim.wiki/Nim-for-Python-Programmers.md:483
msgid "Python programmers use the ternary conditional operator instead:"
msgstr "Em vez disso, os programadores de Python usam o operador condicional ternário:"

#: Nim.wiki/Nim-for-Python-Programmers.md:485
msgid "other = bar if bar is not None else \"default value\"  # \"bar\" may be null?, or not ?."
msgstr "other = bar se bar não for Nenhum outro “valor padrão” # “bar” pode ser nulo? , ou não?."

#: Nim.wiki/Nim-for-Python-Programmers.md:486
msgid ""
"Nim has a [wrapnils module](https://nim-lang.github.io/Nim/wrapnils.html) with a `?.` null-coalescing operator,\n"
"which simplifies code by reducing the need for `if..elif...else` branches around **intermediate values that may be null**."
msgstr ""
"Nim tem um [módulo wrapnils] (https://nim-lang.github.io/Nim/wrapnils.html) com um `?. `operador de coalescência nula,\n"
"o que simplifica o código ao reduzir a necessidade de ramificações `if.. elif... else` em torno de **valores intermediários que podem ser nulos**."

#: Nim.wiki/Nim-for-Python-Programmers.md:488
msgid "assert ?.foo.bar.baz == \"\"  # \"bar\" may be Null?, or not ?."
msgstr "afirmar?. foo.bar.baz == “” # “bar” pode ser Nulo? , ou não?."

#: Nim.wiki/Nim-for-Python-Programmers.md:489
msgid "Null is `None` in Python. Null is `nil` in Nim."
msgstr "Null é `None` em Python. Null é `nil` em Nim."

#: Nim.wiki/Nim-for-Python-Programmers.md:491
msgid "See: https://nim-lang.github.io/Nim/wrapnils.html"
msgstr "Veja: https://nim-lang.github.io/Nim/wrapnils.html"

#: Nim.wiki/Nim-for-Python-Programmers.md:493
msgid "With Context Manager"
msgstr "Com o Context Manager"

#: Nim.wiki/Nim-for-Python-Programmers.md:494
msgid "There is no direct built-in equivalent to Python's `with` construct. In Nim there are the following options:"
msgstr "Não há equivalente embutido direto à construção `with` do Python. No Nim, existem as seguintes opções:"

#: Nim.wiki/Nim-for-Python-Programmers.md:498
msgid "[`template`](#templates)"
msgstr "[`modelo`] (#templates)"

#: Nim.wiki/Nim-for-Python-Programmers.md:501
msgid "[`macros`](https://nim-lang.github.io/Nim/manual.html#macros)"
msgstr "[`macros`] (https://nim-lang.github.io/Nim/manual.html#macros)"

#: Nim.wiki/Nim-for-Python-Programmers.md:504
msgid "Named [`block`](https://nim-lang.github.io/Nim/manual.html#statements-and-expressions-block-statement)"
msgstr "Chamado [`block`] (https://nim-lang.github.io/Nim/manual.html#statements-and-expressions-block-statement)"

#: Nim.wiki/Nim-for-Python-Programmers.md:508
msgid "[See the Templates section for examples.](#templates)"
msgstr "[Consulte a seção Modelos para ver exemplos.] (#templates)"

#: Nim.wiki/Nim-for-Python-Programmers.md:510
msgid "Strings"
msgstr "Cordas"

#: Nim.wiki/Nim-for-Python-Programmers.md:512
msgid "String Ops"
msgstr "Operações de corda"

#: Nim.wiki/Nim-for-Python-Programmers.md:516
msgid "**Nim string operations require [`import std/strutils`.](https://nim-lang.org/docs/strutils.html)**"
msgstr "**As operações de string Nim requerem [`import std/strutils`.] (https://nim-lang.org/docs/strutils.html) **"

#: Nim.wiki/Nim-for-Python-Programmers.md:519
msgid "A [very detailed comparison.](https://scripter.co/notes/string-functions-nim-vs-python/)"
msgstr "[Uma comparação muito detalhada.] (https://scripter.co/notes/string-functions-nim-vs-python/)"

#: Nim.wiki/Nim-for-Python-Programmers.md:523
msgid "String Efficiency"
msgstr "Eficiência de"

#: Nim.wiki/Nim-for-Python-Programmers.md:524
msgid ""
"Single memory allocation strings can be done with `newStringOfCap(capacity = 42)`,\n"
"that returns a new empty string `\"\"` but with allocated `capacity` of `42`. If you pass beyond the `capacity` it will not crash nor buffer overflow:"
msgstr ""
"Cadeias de alocação de memória únicas podem ser feitas com `newStringOfCap (capacity = 42) `,\n"
"que retorna uma nova string vazia `\"\"`, mas com `capacidade` alocada de `42`. Se você ultrapassar a `capacidade`, ela não falhará nem estourará o buffer:"

#: Nim.wiki/Nim-for-Python-Programmers.md:526
msgid ""
"variable = \"\"\n"
"assert variable == \"\" # length is 0, capacity is 0, 1 allocations, 0 copies\n"
"variable += \"a\"       # length is 1, capacity is 1, 2 allocations, 1 copies\n"
"variable += \"b\"       # length is 2, capacity is 2, 3 allocations, 2 copies\n"
"variable += \"c\"       # length is 3, capacity is 3, 4 allocations, 3 copies\n"
"variable += \"d\"       # length is 4, capacity is 4, 5 allocations, 4 copies\n"
"assert variable == \"abcd\" \n"
"# TOTAL: 5 allocations, 4 copies"
msgstr ""
"variável = “”\n"
"variável assert == “” # comprimento é 0, capacidade é 0, 1 alocação, 0 cópias\n"
"variável += “a” # comprimento é 1, capacidade é 1, 2 alocações, 1 cópia\n"
"variável += “b” # o comprimento é 2, a capacidade é 2, 3 alocações, 2 cópias\n"
"variável += “c” # o comprimento é 3, a capacidade é 3, 4 alocações, 3 cópias\n"
"variável += “d” # o comprimento é 4, a capacidade é 4, 5 alocações, 4 cópias\n"
"variável assert == “abcd” \n"
"# TOTAL: 5 alocações, 4 cópias"

#: Nim.wiki/Nim-for-Python-Programmers.md:529
msgid ""
"var variable = newStringOfCap(2)\n"
"assert variable == \"\" # length is 0, capacity is 2, 1 allocations, 0 copies\n"
"variable.add \"a\"      # length is 1, capacity is 2, 1 allocations, 0 copies\n"
"variable.add \"b\"      # length is 2, capacity is 2, 1 allocations, 0 copies\n"
"variable.add \"c\"      # length is 3, capacity is 3, 2 allocations, 0 copies\n"
"variable.add \"d\"      # length is 4, capacity is 4, 3 allocations, 0 copies\n"
"assert variable == \"abcd\" \n"
"# TOTAL: 3 allocations, 0 copies"
msgstr ""
"variável var = newStringOfCap (2)\n"
"variável assert == “” # comprimento é 0, capacidade é 2, 1 alocação, 0 cópias\n"
"variable.add “a” # comprimento é 1, capacidade é 2, 1 alocação, 0 cópias\n"
"variable.add “b” # comprimento é 2, capacidade é 2, 1 alocação, 0 cópias\n"
"variable.add “c” # o comprimento é 3, a capacidade é 3, 2 alocações, 0 cópias\n"
"variable.add “d” # o comprimento é 4, a capacidade é 4, 3 alocações, 0 cópias\n"
"variável assert == “abcd” \n"
"# TOTAL: 3 alocações, 0 cópias"

#: Nim.wiki/Nim-for-Python-Programmers.md:530
msgid "This difference may get bigger for strings inside for loops or while loops."
msgstr "Essa diferença pode ficar maior para cordas internas para loops ou while loops."

#: Nim.wiki/Nim-for-Python-Programmers.md:532
msgid "F-Strings"
msgstr "Cordas F"

#: Nim.wiki/Nim-for-Python-Programmers.md:533
msgid ""
"Nim `strformat` implements formatted string literals inspired by Python f-strings.\n"
"`strformat` is implemented using metaprogramming and the code expansion is done at compile-time.\n"
"It also works for the JavaScript target."
msgstr ""
"Nim `strformat` implementa literais de string formatados inspirados nas strings f do Python.\n"
"O `strformat` é implementado usando metaprogramação e a expansão do código é feita em tempo de compilação.\n"
"Também funciona para o destino JavaScript."

#: Nim.wiki/Nim-for-Python-Programmers.md:535
msgid ""
"Similar to Python f-strings, you can \n"
"[debug the key-value inside the string using an equal sign](https://nim-lang.github.io/Nim/strformat.html#debugging-strings). `fmt\"{key=}\"` expands to `fmt\"key={value}\"`:"
msgstr ""
"Semelhante ao Python f-strings, você pode \n"
"[depure o valor-chave dentro da string usando um sinal de igual] (https://nim-lang.github.io/Nim/strformat.html#debugging-strings). `fmt \"{key=}\" `se expande para `fmt\"key= {value} \"`:"

#: Nim.wiki/Nim-for-Python-Programmers.md:537
msgid ""
"let x = \"hello\"\n"
"assert fmt\"{x=}\" == \"x=hello\"\n"
"assert fmt\"{x   =  }\" == \"x   =  hello\""
msgstr ""
"deixe x = “olá”\n"
"assert fmt \"{x=}” == “x=hello”\n"
"assert fmt \"{x =}” == “x = olá”"

#: Nim.wiki/Nim-for-Python-Programmers.md:538
msgid "Nim `strformat` supports backslash, while Python's f-strings do not:"
msgstr "Nim `strformat` suporta barra invertida, enquanto as strings f do Python não:"

#: Nim.wiki/Nim-for-Python-Programmers.md:540
msgid ""
">>> print( f\"\"\"{ \"yep\\nope\" }\"\"\" ) # Run-time error.\n"
"Error: f-string expression part cannot include a backslash."
msgstr ""
">>> print (f\"\" \"{“yep\\ nope”} \"\"”) # Erro em tempo de execução.\n"
"Erro: a parte da expressão da string f não pode incluir uma barra invertida."

#: Nim.wiki/Nim-for-Python-Programmers.md:543
msgid ""
"echo fmt\"\"\"{ \"yep\\nope\" }\"\"\"       # Nim works.\n"
"\n"
"yep\n"
"ope"
msgstr ""
"echo fmt\"\" \"{“yep\\ nope”} \"\"” # Nim funciona.\n"
"\n"
"sim\n"
"esperança"

#: Nim.wiki/Nim-for-Python-Programmers.md:544
msgid "You can choose a custom character pair to open and close the formatting inside the string by passing the `char` as argument:"
msgstr "Você pode escolher um par de caracteres personalizado para abrir e fechar a formatação dentro da string passando o `char` como argumento:"

#: Nim.wiki/Nim-for-Python-Programmers.md:546
msgid ""
"import std/strformat\n"
"let variable = 42\n"
"assert fmt(\"( variable ) { variable }\", '(', ')') == \"42 { variable }\"\n"
"assert fmt(\"< variable > { variable }\", '<', '>') == \"42 { variable }\""
msgstr ""
"importar formato std/str\n"
"variável let = 42\n"
"assert fmt (“(variável) {variável}”, '(', ')') == “42 {variável}”\n"
"assert fmt (“< variable > {variable}”, '<', '>') == “42 {variável}”"

#: Nim.wiki/Nim-for-Python-Programmers.md:547
msgid "Using characters like backtick and space `' '` works:"
msgstr "Usar caracteres como crachá e espaço `''`funciona:"

#: Nim.wiki/Nim-for-Python-Programmers.md:549
msgid ""
"import std/strformat\n"
"let variable = 42\n"
"assert fmt(\" variable`{variable}\", ' ', '`') == \"42{variable}\""
msgstr ""
"importar formato std/str\n"
"variável let = 42\n"
"assert fmt (” variable` {variable}”, '', '`') == “42 {variável}”"

#: Nim.wiki/Nim-for-Python-Programmers.md:552
msgid "[It is recommended to read the full documentation of `strformat`.](https://nim-lang.github.io/Nim/strformat.html)"
msgstr "[É recomendável ler a documentação completa do `strformat`.] (https://nim-lang.github.io/Nim/strformat.html)"

#: Nim.wiki/Nim-for-Python-Programmers.md:556
msgid "Raw String"
msgstr "Corda crua"

#: Nim.wiki/Nim-for-Python-Programmers.md:557
msgid "Python raw string can not end in `\"\\\"`, but Nim raw string works just fine:"
msgstr "A string bruta do Python não pode terminar em `\"\\\"`, mas a string bruta Nim funciona muito bem:"

#: Nim.wiki/Nim-for-Python-Programmers.md:559
msgid ""
">>> print(r\"\\\")  # Run-time error.\n"
"SyntaxError: EOL while scanning string literal."
msgstr ""
">>> print (r \"\\”) # Erro em tempo de execução.\n"
"SyntaxError: EOL ao digitalizar a string literal."

#: Nim.wiki/Nim-for-Python-Programmers.md:562
msgid ""
"nim> echo r\"\\\"\n"
"\"\\\"\n"
msgstr ""
"nim> echo r \"\\”\n"
"“\\”\n"

#: Nim.wiki/Nim-for-Python-Programmers.md:563
msgid "This may be relevant when working with strings that use `\"\\\"`, like filesystems paths ` r\"C:\\mypath\\\" `, etc."
msgstr "Isso pode ser relevante ao trabalhar com cadeias de caracteres que usam `\"\\\"`, como caminhos de sistemas de arquivos `r” C:\\mypath\\”`, etc."

#: Nim.wiki/Nim-for-Python-Programmers.md:565
msgid "Standard Library Equivalents"
msgstr "Equivalentes de biblioteca padrão"

#: Nim.wiki/Nim-for-Python-Programmers.md:568
msgid "[Python Standard Library for Nim.](https://github.com/juancarlospaco/cpython#alternative-stdlib-for-nim-for-python-targets)"
msgstr "[Biblioteca padrão Python para Nim.] (https://github.com/juancarlospaco/cpython#alternative-stdlib-for-nim-for-python-targets)"

#: Nim.wiki/Nim-for-Python-Programmers.md:575
msgid "This is not complete, but just a quick overview. For more information see https://nim-lang.org/docs/lib.html"
msgstr "Isso não está completo, mas apenas uma visão geral rápida. Para obter mais informações, consulte https://nim-lang.org/docs/lib.html"

#: Nim.wiki/Nim-for-Python-Programmers.md:579
msgid "Tuples"
msgstr "Tuplas"

#: Nim.wiki/Nim-for-Python-Programmers.md:580
msgid "Tuples are fixed size, start at index `0`, can contain mixed types, and can be anonymous or named. Named tuples have no extra overhead over anonymous tuples."
msgstr "As tuplas têm tamanho fixo, começam no índice `0`, podem conter tipos mistos e podem ser anônimas ou nomeadas. Tuplas nomeadas não têm nenhuma sobrecarga extra sobre tuplas anônimas."

#: Nim.wiki/Nim-for-Python-Programmers.md:582
msgid "Anonymous Tuple"
msgstr "Tupla anônima"

#: Nim.wiki/Nim-for-Python-Programmers.md:583 Nim.wiki/Nim-for-Python-Programmers.md:586
msgid "(1, 2, 3)"
msgstr "(1, 2, 3)"

#: Nim.wiki/Nim-for-Python-Programmers.md:587 Nim.wiki/Nim-for-Python-Programmers.md:598
msgid "Named Tuple"
msgstr "Chamado Tuple"

#: Nim.wiki/Nim-for-Python-Programmers.md:590
msgid "Nim allows the fields to be named, without requiring the tuple itself to be named. Python NamedTuple requires `import collections`, and we need to give it a dummy underscore name:"
msgstr "O Nim permite que os campos sejam nomeados, sem exigir que a própria tupla seja nomeada. O Python NamedTuple requer `coleções de importação`, e precisamos dar a ele um nome fictício de sublinhado:"

#: Nim.wiki/Nim-for-Python-Programmers.md:594
msgid "collections.namedtuple(\"_\", \"key0 key1\")(\"foo\", 42)"
msgstr "collections.namedtuple (“_”, “chave0 key1\") (“foo”, 42)"

#: Nim.wiki/Nim-for-Python-Programmers.md:597
msgid "(key0: \"foo\", key1: 42)"
msgstr "(chave 0: “foo”, chave 1:42)"

#: Nim.wiki/Nim-for-Python-Programmers.md:601
msgid "We can also name both the fields and the tuple:"
msgstr "Também podemos nomear os campos e a tupla:"

#: Nim.wiki/Nim-for-Python-Programmers.md:605
msgid "collections.namedtuple(\"NameHere\", \"key0 key1\")(\"foo\", 42)"
msgstr "collections.namedtuple (“NameHere”, “key0 key1\") (“foo”, 42)"

#: Nim.wiki/Nim-for-Python-Programmers.md:608
msgid ""
"type NameHere = tuple[key0: string, key1: int]\n"
"var variable: NameHere = (key0: \"foo\", key1: 42)"
msgstr ""
"digite nameHere = tuple [key0: string, key1: int]\n"
"variável var: nameHere = (key0: “foo”, key1:42)"

#: Nim.wiki/Nim-for-Python-Programmers.md:609
msgid ""
"`tuple[key0: string, key1: int]` is the `typedesc` for Declarations.\n"
"`(key0: \"foo\", key1: 42)` is the Literal for Assigns."
msgstr ""
"`tuple [key0: string, key1: int] `é o `typedesc` para Declarações.\n"
"`(key0: “foo”, key1:42)` é o literal para atribuições."

#: Nim.wiki/Nim-for-Python-Programmers.md:611
msgid "Nim tuples are a lot like Python NamedTuple in that the tuple members have names."
msgstr "As tuplas Nim são muito parecidas com Python NamedTuple, pois os membros da tupla têm nomes."

#: Nim.wiki/Nim-for-Python-Programmers.md:613
msgid "Do NOT use named tuples to \"mimic\" proper objects (the compiler re-uses generic instantiations for \"identical\" tuples)."
msgstr "NÃO use tuplas nomeadas para “imitar” objetos apropriados (o compilador reutiliza instanciações genéricas para tuplas “idênticas”)."

#: Nim.wiki/Nim-for-Python-Programmers.md:615
msgid "See [manual](http://nim-lang.org/docs/manual.html#types-tuples-and-object-types) for a more in depth look at tuples."
msgstr "Veja [manual] (http://nim-lang.org/docs/manual.html#types-tuples-and-object-types) para uma análise mais aprofundada das tuplas."

#: Nim.wiki/Nim-for-Python-Programmers.md:617
msgid "Lists"
msgstr "Listas"

#: Nim.wiki/Nim-for-Python-Programmers.md:618
msgid "[Nim sequences](http://nim-lang.org/docs/tut1.html#advanced-types-sequences) are *not* fixed size. They can grow and shrink, start at index `0`, and must contain elements all of the same type."
msgstr "[Sequências Nim] (http://nim-lang.org/docs/tut1.html#advanced-types-sequences) *não* são de tamanho fixo. Eles podem crescer e encolher, começar no índice `0` e devem conter elementos do mesmo tipo."

#: Nim.wiki/Nim-for-Python-Programmers.md:620
msgid "[\"foo\", \"bar\", \"baz\"]"
msgstr "[\"foo”, “bar”, “baz\"]"

#: Nim.wiki/Nim-for-Python-Programmers.md:623
msgid "@[\"foo\", \"bar\", \"baz\"]"
msgstr "@ [\"foo”, “bar”, “baz\"]"

#: Nim.wiki/Nim-for-Python-Programmers.md:624 Nim.wiki/Nim-for-Python-Programmers.md:851
msgid ""
"[@](https://nim-lang.github.io/Nim/system.html#%40%2CopenArray%5BT%5D) \n"
"is a function that converts from `array` to `seq`."
msgstr ""
"[@] (https://nim-lang.github.io/Nim/system.html#%40%2CopenArray%5BT%5D) \n"
"é uma função que converte de `array` para `seq`."

#: Nim.wiki/Nim-for-Python-Programmers.md:626
msgid "List Comprehensions"
msgstr "Listar compreensões"

#: Nim.wiki/Nim-for-Python-Programmers.md:627
msgid "variable = [item for item in (-9, 1, 42, 0, -1, 9)]"
msgstr "variável = [item para item em (-9, 1, 42, 0, -1, 9)]"

#: Nim.wiki/Nim-for-Python-Programmers.md:630
msgid ""
"let variable = collect(newSeq):\n"
"  for item in @[-9, 1, 42, 0, -1, 9]: item"
msgstr ""
"variável let = collect (newSeq):\n"
" para o item em @ [-9, 1, 42, 0, -1, 9]: item"

#: Nim.wiki/Nim-for-Python-Programmers.md:631
msgid "A comprehension can be assigned to `const` too, and it will run at compile-time."
msgstr "Uma compreensão também pode ser atribuída a `const` e será executada em tempo de compilação."

#: Nim.wiki/Nim-for-Python-Programmers.md:633
msgid ""
"The comprehension is implemented as a `macro` that is expanded at compile-time, \n"
"you can see the expanded code using the `--expandMacro` compiler option:"
msgstr ""
"A compreensão é implementada como uma `macro` que é expandida em tempo de compilação, \n"
"você pode ver o código expandido usando a opção de compilador `—expandMacro`:"

#: Nim.wiki/Nim-for-Python-Programmers.md:635
msgid ""
"let variable = \n"
"  var collectResult = newSeq(Natural(0))\n"
"  for item in items(@[-9, 1, 42, 0, -1, 9]):\n"
"    add(collectResult, item)\n"
"  collectResult\n"
msgstr ""
"deixe variável = \n"
" var collectResult = newSeq (Natural (0))\n"
" para o item em itens (@ [-9, 1, 42, 0, -1, 9]):\n"
" adicionar (ColetResult, item)\n"
" Coletar resultado\n"

#: Nim.wiki/Nim-for-Python-Programmers.md:636
msgid "The comprehensions can be nested, multi-line, multi-expression, all with zero overhead:"
msgstr "As compreensões podem ser aninhadas, com várias linhas e com várias expressões, tudo sem sobrecarga:"

#: Nim.wiki/Nim-for-Python-Programmers.md:638
msgid ""
"import std/sugar\n"
"\n"
"let values = collect(newSeq):\n"
"  for val in [1, 2]:\n"
"    collect(newSeq):\n"
"      for val2 in [3, 4]:\n"
"        if (val, val2) != (1, 2):\n"
"          (val, val2)\n"
"\n"
"assert values == @[@[(1, 3), (1, 4)], @[(2, 3), (2, 4)]]"
msgstr ""
"importar std/açúcar\n"
"\n"
"deixe valores = coletar (newSeq):\n"
" para val em [1, 2]:\n"
" coletar (NewSeq):\n"
" para val2 em [3, 4]:\n"
" if (val, val2)! = (1, 2):\n"
" (val, val2)\n"
"\n"
"valores de afirmação == @ [@ [(1, 3), (1, 4)], @ [(2, 3), (2, 4)]]"

#: Nim.wiki/Nim-for-Python-Programmers.md:639
msgid "Single-line example:"
msgstr "Exemplo de linha única:"

#: Nim.wiki/Nim-for-Python-Programmers.md:641
msgid "print([i for i in range(0, 9)])"
msgstr "print ([i para i no intervalo (0, 9)])"

#: Nim.wiki/Nim-for-Python-Programmers.md:644
msgid "echo(block: collect newSeq: (for i in 0..9: i))"
msgstr "echo (block: collect newSeq: (para i em 0.. 9: i))"

#: Nim.wiki/Nim-for-Python-Programmers.md:645
msgid "Python comprehensions convert the code to a generator, but Nim comprehensions do not convert the code to an iterator:"
msgstr "As compreensões de Python convertem o código em um gerador, mas as compreensões de Nim não convertem o código em um iterador:"

#: Nim.wiki/Nim-for-Python-Programmers.md:647
msgid ""
"import std/sugar\n"
"\n"
"func example() =\n"
"  discard collect(newSeq):\n"
"    for item in @[-9, 1, 42, 0, -1, 9]: \n"
"      if item == 0: return\n"
"      item\n"
"\n"
"example()"
msgstr ""
"importar std/açúcar\n"
"\n"
"exemplo de função () =\n"
" descartar e coletar (NewSeq):\n"
" para o item em @ [-9, 1, 42, 0, -1, 9]: \n"
" se o item == 0: retornar\n"
" item\n"
"\n"
"exemplo ()"

#: Nim.wiki/Nim-for-Python-Programmers.md:648
msgid ":arrow_up: Nim :arrow_up: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :arrow_down: Python :arrow_down:"
msgstr ":arrow_up: NIM:arrow_up: :arrow_down: Python:arrow_down:"

#: Nim.wiki/Nim-for-Python-Programmers.md:650
msgid ""
"def example():\n"
"  [item for item in [-9, 1, 42, 0, -1, 9] if item == 0: return]\n"
"\n"
"example()"
msgstr ""
"def example ():\n"
" [item para item em [-9, 1, 42, 0, -1, 9] se item == 0: retornar]\n"
"\n"
"exemplo ()"

#: Nim.wiki/Nim-for-Python-Programmers.md:651
msgid "Python complains:"
msgstr "Python reclama:"

#: Nim.wiki/Nim-for-Python-Programmers.md:654
msgid "Some things that in Python are syntactically disallowed inside comprehensions (like `return`) are allowed in Nim. This is because Nim comprehensions are just macros that expand to normal code."
msgstr "Algumas coisas que em Python são sintaticamente proibidas dentro de compreensões (como `return`) são permitidas no Nim. Isso ocorre porque as compreensões do Nim são apenas macros que se expandem para o código normal."

#: Nim.wiki/Nim-for-Python-Programmers.md:658
msgid "Whats `collect()`?."
msgstr "O que é `collect () `?."

#: Nim.wiki/Nim-for-Python-Programmers.md:662
msgid ""
"[collect](https://nim-lang.github.io/Nim/sugar.html#collect.m%2Cuntyped%2Cuntyped) \n"
"takes as argument whatever your returning type uses as the constructor."
msgstr ""
"[coletar] (https://nim-lang.github.io/Nim/sugar.html#collect.m%2Cuntyped%2Cuntyped) \n"
"toma como argumento qualquer que seu tipo de retorno use como construtor."

#: Nim.wiki/Nim-for-Python-Programmers.md:664
msgid "Dict Comprehensions"
msgstr "Compreensões do Dict"

#: Nim.wiki/Nim-for-Python-Programmers.md:665
msgid "variable = {key: value for key, value in enumerate((-9, 1, 42, 0, -1, 9))}"
msgstr "variable = {key: valor para chave, valor em enumerado ((-9, 1, 42, 0, -1, 9))}"

#: Nim.wiki/Nim-for-Python-Programmers.md:668
msgid ""
"let variable = collect(initTable(4)):\n"
"  for key, value in @[-9, 1, 42, 0, -1, 9]: {key: value}"
msgstr ""
"deixe variável = collect (initTable (4)):\n"
" para chave, valor em @ [-9, 1, 42, 0, -1, 9]: {chave: valor}"

#: Nim.wiki/Nim-for-Python-Programmers.md:671 Nim.wiki/Nim-for-Python-Programmers.md:682
msgid "`collect()` requires [`import std/sugar`.](https://nim-lang.github.io/Nim/sugar.html#collect.m%2Cuntyped%2Cuntyped)"
msgstr "`collect () `requer [`import std/sugar`.] (https://nim-lang.github.io/Nim/sugar.html#collect.m%2Cuntyped%2Cuntyped)"

#: Nim.wiki/Nim-for-Python-Programmers.md:675
msgid "Set Comprehensions"
msgstr "Defina compreensões"

#: Nim.wiki/Nim-for-Python-Programmers.md:676
msgid "variable = {item for item in (-9, 1, 42, 0, -1, 9)}"
msgstr "variável = {item para item em (-9, 1, 42, 0, -1, 9)}"

#: Nim.wiki/Nim-for-Python-Programmers.md:679
msgid ""
"let variable = collect(initHashSet):\n"
"  for item in @[-9, 1, 42, 0, -1, 9]: {item}"
msgstr ""
"variável de saída = coletar (initHashSet):\n"
" para o item em @ [-9, 1, 42, 0, -1, 9]: {item}"

#: Nim.wiki/Nim-for-Python-Programmers.md:686
msgid "Sets"
msgstr "Conjuntos"

#: Nim.wiki/Nim-for-Python-Programmers.md:688
msgid ""
":snake: Python              | `set()`    | :negative_squared_cross_mark: | :negative_squared_cross_mark: | :negative_squared_cross_mark: |               | \n"
":crown: Nim                 | [`HashSet()`](https://nim-lang.github.io/Nim/sets.html#HashSet) | [`OrderedSet()`](https://nim-lang.github.io/Nim/sets.html#OrderedSet)       | [`set`](http://nim-lang.org/docs/manual.html#types-set-type) | [Bit Fields](https://nim-lang.org/docs/manual.html#set-type-bit-fields) | `import std/sets` |   "
msgstr ""
":cobra: Python | `set () `|:negative_squared_cross_mark: |:negative_squared_cross_mark: |:negative_squared_cross_mark: | | \n"
":crown: Nim | [`HashSet () `] (https://nim-lang.github.io/Nim/sets.html#HashSet) | [`OrderedSet ()`] (https://nim-lang.github.io/Nim/sets.html#OrderedSet) | [`set`] (http://nim-lang.org/docs/manual.html#types-set-type) | [Campos de bits] (https://nim-lang.org/docs/manual.html#set-type-bit-fields) | `importar std/sets` |   "

#: Nim.wiki/Nim-for-Python-Programmers.md:692
msgid "**Python Set can be replaced with [HashSet](http://nim-lang.org/docs/sets.html).**"
msgstr "**O conjunto Python pode ser substituído por [HashSet] (http://nim-lang.org/docs/sets.html) .**"

#: Nim.wiki/Nim-for-Python-Programmers.md:696
msgid ""
"Python sets are not like the [Nim set type](http://nim-lang.org/docs/manual.html#types-set-type). The \"default\" set is a [bitset](https://en.wikipedia.org/wiki/Bitset). For every possible value of the contained type, it stores 1 bit indicating whether it is present in the set. This means you should use it if the type has a "
"finite, limited range of possible values. If all of the possible values are also known at compile-time, you can create an `Enum` for them."
msgstr ""
"Os conjuntos Python não são como o [tipo de conjunto Nim] (http://nim-lang.org/docs/manual.html#types-set-type). O conjunto “padrão” é um [bitset] (https://en.wikipedia.org/wiki/Bitset). Para cada valor possível do tipo contido, ele armazena 1 bit indicando se ele está presente no conjunto. Isso significa que você deve usá-lo se o "
"tipo tiver uma faixa finita e limitada de valores possíveis. Se todos os valores possíveis também forem conhecidos em tempo de compilação, você poderá criar um `Enum` para eles."

#: Nim.wiki/Nim-for-Python-Programmers.md:698
msgid "The biggest integer you can fit on a set normally is `65535` equals to `high(uint16)`."
msgstr "O maior número inteiro que você pode caber em um conjunto normalmente é `65535` igual a `high (uint16) `."

#: Nim.wiki/Nim-for-Python-Programmers.md:700
msgid "You can fit bigger integers using an integer Subrange, if you don't need small integers. An example really stressing set to fit `2_147_483_647` equals to `high(int32)` on a set at compile-time:"
msgstr "Você pode ajustar números inteiros maiores usando um Subintervalo inteiro, se não precisar de números inteiros pequenos. Um exemplo realmente estressante de definir para caber `2_147_483_647` é igual a `high (int32) `em um conjunto em tempo de compilação:"

#: Nim.wiki/Nim-for-Python-Programmers.md:702
msgid ""
"const x = {range[2147483640..2147483647](2147483647)}\n"
"assert x is set  # Equals to {2147483647}"
msgstr ""
"const x = {faixa [2147483640.. 2147483647] (2147483647)}\n"
"assert x é definido como # é igual a {2147483647}"

#: Nim.wiki/Nim-for-Python-Programmers.md:703
msgid "The basic Nim set type is fast and memory-efficient, compared to the [HashSet](http://nim-lang.org/docs/sets.html) which is implemented as a dictionary. For simple flag types and small mathematical sets, use set. For larger collections, or if you are just learning, use HashSet."
msgstr "O tipo de conjunto básico do Nim é rápido e economiza memória, em comparação com o [HashSet] (http://nim-lang.org/docs/sets.html), que é implementado como um dicionário. Para tipos de bandeiras simples e pequenos conjuntos matemáticos, use set. Para coleções maiores, ou se você está apenas aprendendo, use o HashSet."

#: Nim.wiki/Nim-for-Python-Programmers.md:705
msgid "Dictionaries"
msgstr "Dicionários"

#: Nim.wiki/Nim-for-Python-Programmers.md:706
msgid "Use [tables](http://nim-lang.org/docs/tables.html) for Python-like dicts."
msgstr "Use [tables] (http://nim-lang.org/docs/tables.html) para dicionários semelhantes ao Python."

#: Nim.wiki/Nim-for-Python-Programmers.md:709
msgid ""
":snake: Python              | `dict()`   | `OrderedDict()`             | `Counter()`    | `import std/collections` | \n"
":crown: Nim                 | [`Table()`](https://nim-lang.org/docs/tables.html#basic-usage-table) |  [`OrderedTable()`](https://nim-lang.org/docs/tables.html#basic-usage-orderedtable) | [`CountTable()`](https://nim-lang.org/docs/tables.html#basic-usage-counttable) | `import std/tables`      |   "
msgstr ""
":snake: Python | `dict () `| `OrderedDict ()` | `Counter () `| `importar std/collections` | \n"
":crown: Nim | [`Table () `] (https://nim-lang.org/docs/tables.html#basic-usage-table) | [`OrderedTable ()`] (https://nim-lang.org/docs/tables.html#basic-usage-orderedtable) | [`CountTable () `] (https://nim-lang.org/docs/tables.html#basic-usage-counttable) | `importar std/tabelas` |   "

#: Nim.wiki/Nim-for-Python-Programmers.md:711
msgid "Table Constructors"
msgstr "Construtores de tabela"

#: Nim.wiki/Nim-for-Python-Programmers.md:712
msgid "dict(key=\"value\", other=\"things\")"
msgstr "dict (chave=\"valor”, outro=\"coisas”)"

#: Nim.wiki/Nim-for-Python-Programmers.md:715
msgid "to_table({\"key\": \"value\", \"other\": \"things\"})"
msgstr "to_table ({\"key”: “valor”, “outro”: “coisas\"})"

#: Nim.wiki/Nim-for-Python-Programmers.md:716
msgid "Ordered Dictionary"
msgstr "Dicionário solicitado"

#: Nim.wiki/Nim-for-Python-Programmers.md:717
msgid "collections.OrderedDict([(8, \"hp\"), (4, \"laser\"), (9, \"engine\")])"
msgstr "collections.OrderedDict ([(8, “hp”), (4, “laser”), (9, “motor”)])"

#: Nim.wiki/Nim-for-Python-Programmers.md:720
msgid "to_ordered_table({8: \"hp\", 4: \"laser\", 9: \"engine\"})"
msgstr "to_ordered_table ({8: “hp”, 4: “laser”, 9: “motor\"})"

#: Nim.wiki/Nim-for-Python-Programmers.md:721
msgid "Counters"
msgstr "Contadores"

#: Nim.wiki/Nim-for-Python-Programmers.md:722
msgid "collections.Counter([\"a\", \"b\", \"c\", \"a\", \"b\", \"b\"])"
msgstr "colecoes.contador ([\"a”, “b”, “c”, “a”, “b”, “b\"])"

#: Nim.wiki/Nim-for-Python-Programmers.md:725
msgid "to_count_table(\"abcabb\")"
msgstr "to_count_table (“abcabb”)"

#: Nim.wiki/Nim-for-Python-Programmers.md:726
msgid "**Examples:**"
msgstr "**Exemplos: **"

#: Nim.wiki/Nim-for-Python-Programmers.md:728
msgid ""
"import std/tables\n"
"\n"
"var dictionary = to_table({\"hi\": 1, \"there\": 2})\n"
"\n"
"assert dictionary[\"hi\"] == 1\n"
"dictionary[\"hi\"] = 42\n"
"assert dictionary[\"hi\"] == 42\n"
"\n"
"assert len(dictionary) == 2\n"
"assert dictionary.has_key(\"hi\")\n"
"\n"
"for key, value in dictionary:\n"
"  echo key, value"
msgstr ""
"import std/tables\n"
"\n"
"var dicionario = to_table ({\"oi”: 1, “lá”: 2})\n"
"\n"
"dicionario assert [\"oi\"] == 1\n"
"dicionario [\"oi\"] = 42\n"
"dicionario assert [\"oi\"] == 42\n"
"\n"
"assert len (dicionario) == 2\n"
"assert dicionário.has_key (“oi”)\n"
"\n"
"for chave, valor in dicionario:\n"
" echo chave, valor"

#: Nim.wiki/Nim-for-Python-Programmers.md:729
msgid "Tables are just syntax sugar for an array of tuples:"
msgstr "As tabelas são apenas açúcar de sintaxe para uma matriz de tuplas:"

#: Nim.wiki/Nim-for-Python-Programmers.md:731
msgid ""
"assert {\"key\": \"value\", \"k\": \"v\"} == [(\"key\", \"value\"), (\"k\", \"v\")]\n"
"assert {\"key\": true, \"k\": false} == @[(\"key\", true),  (\"k\", false)]"
msgstr ""
"assert {\"key”: “valor”, “k”: “v\"} == [(“chave”, “valor”), (“k”, “v”)]\n"
"assert {\"key”: true, “k”: false} == @ [(“chave”, verdadeiro), (“k”, falso)]"

#: Nim.wiki/Nim-for-Python-Programmers.md:732
msgid "B-Tree Tables"
msgstr "Mesas B-Tree"

#: Nim.wiki/Nim-for-Python-Programmers.md:733
msgid "[B-Tree based generic sorted Tables](https://nim-lang.github.io/Nim/btreetables.html) using the same API."
msgstr "[Tabelas classificadas genéricas baseadas em B-Tree] (https://nim-lang.github.io/Nim/btreetables.html) usando a mesma API."

#: Nim.wiki/Nim-for-Python-Programmers.md:739
msgid "[Whats B-Tree ? (Wikipedia).](https://en.wikipedia.org/wiki/B-tree)"
msgstr "[O que é B-Tree? (Wikipédia).] (https://en.wikipedia.org/wiki/B-tree)"

#: Nim.wiki/Nim-for-Python-Programmers.md:742
msgid "[Whats B-Tree ? (1 Minute Animated Video).](https://youtu.be/coRJrcIYbF4)"
msgstr "[O que é B-Tree? (Vídeo animado de 1 minuto).] (https://youtu.be/coRJrcIYbF4)"

#: Nim.wiki/Nim-for-Python-Programmers.md:746
msgid "Ternary operators"
msgstr "Operadores ternários"

#: Nim.wiki/Nim-for-Python-Programmers.md:747
msgid "\"result0\" if conditional else \"result1\""
msgstr "“resulto0\" se for condicional, senão “resultado1\""

#: Nim.wiki/Nim-for-Python-Programmers.md:750
msgid "if conditional: \"result0\" else: \"result1\""
msgstr "se condicional: “result0\" else: “resultado1\""

#: Nim.wiki/Nim-for-Python-Programmers.md:751
msgid "In Nim the \"ternary operator\" is simply an `if..else` inline. Unlike Python, the ordinary `if..else` is an expression, so it can be assigned to a variable. These snippets are equivalent:"
msgstr "Em Nim, o “operador ternário” é simplesmente um `if.. else` em linha. Ao contrário do Python, o `if.. else` comum é uma expressão, portanto, ele pode ser atribuído a uma variável. Esses trechos são equivalentes:"

#: Nim.wiki/Nim-for-Python-Programmers.md:753
msgid ""
"var foo = if 3 < 10:\n"
"  50\n"
"  else: 100"
msgstr ""
"var foo = se 3 < 10:\n"
" 50\n"
" mais: 100"

#: Nim.wiki/Nim-for-Python-Programmers.md:754
msgid "var foo = if 3 < 10: 50 else: 100"
msgstr "var foo = if 3 < 10:50 senão: 100"

#: Nim.wiki/Nim-for-Python-Programmers.md:755
msgid "Reading and writing files"
msgstr "Lendo e escrevendo arquivos"

#: Nim.wiki/Nim-for-Python-Programmers.md:756
msgid "**Reading files line by line**"
msgstr "**Lendo arquivos linha por linha**"

#: Nim.wiki/Nim-for-Python-Programmers.md:758
msgid ""
"with open(\"yourfile.txt\", \"r\") as f:\n"
"    for line in f:\n"
"        print(line)\n"
msgstr ""
"com open (” yourfile.txt “, “r”) como f:\n"
" para a linha em f:\n"
" imprimir (linha)\n"

#: Nim.wiki/Nim-for-Python-Programmers.md:761
msgid ""
"for line in lines(\"yourfile.txt\"):\n"
"  echo line"
msgstr ""
"para linha em linhas (” yourfile.txt “):\n"
" linha echo"

#: Nim.wiki/Nim-for-Python-Programmers.md:764
msgid "`lines()` Documentation https://nim-lang.org/docs/io.html#lines.i%2Cstring"
msgstr "`lines () `Documentação https://nim-lang.org/docs/io.html#lines.i%2Cstring"

#: Nim.wiki/Nim-for-Python-Programmers.md:768
msgid "**Reading and writing files:**"
msgstr "**Lendo e gravando arquivos: **"

#: Nim.wiki/Nim-for-Python-Programmers.md:770
msgid ""
"write_file(\"yourfile.txt\", \"this string simulates data\")\n"
"assert read_file(\"yourfile.txt\") == \"this string simulates data\""
msgstr ""
"write_file (” yourfile.txt “, “esta string simula dados”)\n"
"assert read_file (” yourfile.txt “) == “esta string simula dados”"

#: Nim.wiki/Nim-for-Python-Programmers.md:771
msgid "**Reading files at compile-time:**"
msgstr "**Lendo arquivos em tempo de compilação: **"

#: Nim.wiki/Nim-for-Python-Programmers.md:773
msgid "const constant = static_read(\"yourfile.txt\")  # Returns a string at compile-time"
msgstr "const constant = static_read (” yourfile.txt “) # Retorna uma string em tempo de compilação"

#: Nim.wiki/Nim-for-Python-Programmers.md:774
msgid "Change File Permissions"
msgstr "Alterar permissões de arquivo"

#: Nim.wiki/Nim-for-Python-Programmers.md:775
msgid ""
"import std/os\n"
"os.chmod(\"file.txt\", 0o777)"
msgstr ""
"importar std/os\n"
"os.chmod (” file.txt “, 0o777)"

#: Nim.wiki/Nim-for-Python-Programmers.md:778
msgid ""
"import fusion/filepermissions\n"
"chmod \"file.txt\", 0o777"
msgstr ""
"permissões de importação/fusão de arquivos\n"
"chmod \"file.txt “, 0o777"

#: Nim.wiki/Nim-for-Python-Programmers.md:779
msgid ""
"These examples assume a file `\"file.txt\"` exists.\n"
"[Both use the octal Unix file permissions.](https://en.wikipedia.org/wiki/File-system_permissions#Notation_of_traditional_Unix_permissions)\n"
"[Also a lower level API is available on `os` module.](https://nim-lang.github.io/Nim/os.html#setFilePermissions%2Cstring%2Cset%5BFilePermission%5D)"
msgstr ""
"Esses exemplos assumem que existe um arquivo `” file.txt “`.\n"
"[Ambos usam as permissões octais de arquivo Unix.] (https://en.wikipedia.org/wiki/File-system_permissions#Notation_of_traditional_Unix_permissions)\n"
"[Além disso, uma API de nível inferior está disponível no módulo `os`.] (https://nim-lang.github.io/Nim/os.html#setFilePermissions%2Cstring%2Cset%5BFilePermission%5D)"

#: Nim.wiki/Nim-for-Python-Programmers.md:781
msgid "See https://nim-lang.github.io/fusion/src/fusion/filepermissions.html"
msgstr "Veja https://nim-lang.github.io/fusion/src/fusion/filepermissions.html"

#: Nim.wiki/Nim-for-Python-Programmers.md:783
msgid "Temporarily Change Folder"
msgstr "Alterar pasta temporariamente"

#: Nim.wiki/Nim-for-Python-Programmers.md:784
msgid ""
"import std/os\n"
"\n"
"class withDir:\n"
"    # Unsafe without a __del__()\n"
"\n"
"    def __init__(self, newPath):\n"
"        self.newPath = os.path.expanduser(newPath)\n"
"\n"
"    def __enter__(self):\n"
"        self.savedPath = os.getcwd()\n"
"        os.chdir(self.newPath)\n"
"\n"
"    def __exit__(self, etype, value, traceback):\n"
"        os.chdir(self.savedPath)\n"
"\n"
"\n"
"with withDir(\"subfolder\"):\n"
"  print(\"Inside subfolder\")\n"
"print(\"Go back outside subfolder\")"
msgstr ""
"importar std/os\n"
"\n"
"classe com Dir:\n"
" # Inseguro sem um __del__ ()\n"
"\n"
" def __init__ (self, newPath):\n"
" self.newPath = os.path.expanduser (newPath)\n"
"\n"
" def __enter__ (self):\n"
" self.savedPath = os.getcwd ()\n"
" os.chdir (self.newPath)\n"
"\n"
" def __exit__ (self, type, value, traceback):\n"
" os.chdir (self.SavedPath)\n"
"\n"
"\n"
"com withDir (“subpasta”):\n"
" print (“Subpasta interna”)\n"
"print (“Voltar para fora da subpasta”)"

#: Nim.wiki/Nim-for-Python-Programmers.md:787
msgid ""
"import fusion/scripting\n"
"\n"
"withDir \"subfolder\":\n"
"  echo \"Inside subfolder\"\n"
"echo \"Go back outside subfolder\""
msgstr ""
"fusão de importação/script\n"
"\n"
"Com a “subpasta” Dir:\n"
" echo “Dentro da subpasta”\n"
"echo “Voltar para fora da subpasta”"

#: Nim.wiki/Nim-for-Python-Programmers.md:788
msgid ""
"These examples assume a folder `\"subfolder\"` exists.\n"
"Python optionally has third-party dependencies which do the same thing; the examples use the standard library.\n"
"Some Python third-party dependencies may convert the code inside `withDir` to a generator, forcing you to change the code (like `return` to `yield` etc), examples use standard library."
msgstr ""
"Esses exemplos assumem que existe uma pasta `\"subpasta\"`.\n"
"Opcionalmente, o Python tem dependências de terceiros que fazem a mesma coisa; os exemplos usam a biblioteca padrão.\n"
"Algumas dependências de terceiros do Python podem converter o código dentro de `withDir` em um gerador, forçando você a alterar o código (como `return` para `yield` etc), exemplos usam biblioteca padrão."

#: Nim.wiki/Nim-for-Python-Programmers.md:790
msgid "See https://nim-lang.github.io/fusion/src/fusion/scripting.html"
msgstr "Veja https://nim-lang.github.io/fusion/src/fusion/scripting.html"

#: Nim.wiki/Nim-for-Python-Programmers.md:792
msgid "Map & Filter"
msgstr "Mapa e filtro"

#: Nim.wiki/Nim-for-Python-Programmers.md:793
msgid ""
"def isPositive(arg: int) -> bool: \n"
"  return arg > 0\n"
"\n"
"map(isPositive, [1, 2,-3, 5, -9])\n"
"filter(isPositive, [1, 2,-3, 5, -9])"
msgstr ""
"def é Positivo (arg: int) -> bool: \n"
" argila de retorno > 0\n"
"\n"
"mapa (é positivo, [1, 2, -3, 5, -9])\n"
"filtro (IsPositive, [1, 2, -3, 5, -9])"

#: Nim.wiki/Nim-for-Python-Programmers.md:796
msgid ""
"proc isPositive(arg: int): bool = \n"
"  return arg > 0 \n"
"\n"
"echo map([1, 2,-3, 5, -9], isPositive)\n"
"echo filter([1, 2,-3, 5, -9], isPositive)"
msgstr ""
"proc isPositive (arg: int): bool = \n"
" argila de retorno > 0 \n"
"\n"
"mapa de eco ([1, 2, -3, 5, -9], é positivo)\n"
"filtro de eco ([1, 2, -3, 5, -9], é positivo)"

#: Nim.wiki/Nim-for-Python-Programmers.md:799
msgid "map and filter operations require [`import std/sequtils`.](https://nim-lang.org/docs/sequtils.html)"
msgstr "operações de mapa e filtro requerem [`import std/sequtils`.] (https://nim-lang.org/docs/sequtils.html)"

#: Nim.wiki/Nim-for-Python-Programmers.md:803
msgid "Lambdas"
msgstr "Lambdas"

#: Nim.wiki/Nim-for-Python-Programmers.md:804
msgid "variable: typing.Callable[[int, int], int] = lambda var1, var2: var1 + var2"
msgstr "variável: typing.callable [[int, int], int] = lambda var1, var2: var1 + var2"

#: Nim.wiki/Nim-for-Python-Programmers.md:807
msgid "var variable = proc (var1, var2: int): int = var1 + var2"
msgstr "variável var = proc (var1, var2: int): int = var1 + var2"

#: Nim.wiki/Nim-for-Python-Programmers.md:808
msgid "Multi-line example:"
msgstr "Exemplo de várias linhas:"

#: Nim.wiki/Nim-for-Python-Programmers.md:810
msgid ""
"var anon = func (x: int): bool =\n"
"             if x > 0:\n"
"               result = true\n"
"             else: \n"
"               result = false\n"
"\n"
"assert anon(9)"
msgstr ""
"var anon = func (x: int): bool =\n"
" se x > 0:\n"
" resultado = verdadeiro\n"
" senão: \n"
" resultado = falso\n"
"\n"
"canhão afirmado (9)"

#: Nim.wiki/Nim-for-Python-Programmers.md:811
msgid "Python anonymous functions can not use `return`, but it just works in Nim: "
msgstr "As funções anônimas do Python não podem usar `return`, mas funcionam apenas no Nim: "

#: Nim.wiki/Nim-for-Python-Programmers.md:813
msgid ""
"example = lambda: return 42\n"
"assert example() == 42"
msgstr ""
"exemplo = lambda: return 42\n"
"exemplo de assert () = 42"

#: Nim.wiki/Nim-for-Python-Programmers.md:814 Nim.wiki/Nim-for-Python-Programmers.md:822
msgid "Complains `SyntaxError: invalid syntax`."
msgstr "Reclamações `SyntaxError: sintaxe inválida`."

#: Nim.wiki/Nim-for-Python-Programmers.md:818
msgid ""
"let example = func: int = return 42\n"
"assert example() == 42"
msgstr ""
"vamos exemplo = func: int = return 42\n"
"exemplo de assert () = 42"

#: Nim.wiki/Nim-for-Python-Programmers.md:819
msgid "Python anonymous functions can not use `yield`, but it just works in Nim: "
msgstr "As funções anônimas do Python não podem usar `yield`, mas funcionam apenas no Nim: "

#: Nim.wiki/Nim-for-Python-Programmers.md:821
msgid ""
"example = lambda: for i in range(0, 9): yield i\n"
"\n"
"for _ in example(): pass"
msgstr ""
"exemplo = lambda: para i no intervalo (0, 9): rendimento i\n"
"\n"
"para _ em exemplo (): passe"

#: Nim.wiki/Nim-for-Python-Programmers.md:826
msgid ""
"let example = iterator: int = \n"
"  for i in 0..9: yield i\n"
"\n"
"for _ in example(): discard"
msgstr ""
"seja exemplo = iterador: int = \n"
" para i em 0,9: rendimento i\n"
"\n"
"para _ em exemplo (): descartar"

#: Nim.wiki/Nim-for-Python-Programmers.md:827
msgid "[Anonymous procs in Nim](https://nim-lang.org/docs/manual.html#procedures-anonymous-procs) are basically functions without a name."
msgstr "[Processos anônimos em Nim] (https://nim-lang.org/docs/manual.html#procedures-anonymous-procs) são basicamente funções sem nome."

#: Nim.wiki/Nim-for-Python-Programmers.md:829
msgid "Decorators"
msgstr "Decoradores"

#: Nim.wiki/Nim-for-Python-Programmers.md:832
msgid "Templates and macros can be used similarly to Python's decorators."
msgstr "Modelos e macros podem ser usados de forma semelhante aos decoradores do Python."

#: Nim.wiki/Nim-for-Python-Programmers.md:836
msgid ""
"def decorator(argument):\n"
"  print(\"This is a Decorator\") \n"
"  return argument\n"
"\n"
"@decorator\n"
"def function_with_decorator() -> int:\n"
"  return 42\n"
"\n"
"print(function_with_decorator())\n"
msgstr ""
"decorador de definição (argumento):\n"
" print (“Este é um decorador”) \n"
" argumento de retorno\n"
"\n"
"@decorator\n"
"def function_with_decorator () -> int:\n"
" retorno 42\n"
"\n"
"print (function_with_decorator ())\n"

#: Nim.wiki/Nim-for-Python-Programmers.md:839
msgid ""
"template decorator(argument: untyped) =\n"
"  echo \"This mimics a Decorator\"\n"
"  argument\n"
"\n"
"func function_with_decorator(): int {.decorator.} =\n"
"  return 42\n"
"\n"
"echo function_with_decorator()"
msgstr ""
"decorador de modelo (argumento: sem tipo) =\n"
" echo “Isso imita um decorador”\n"
" discussão\n"
"\n"
"função function_with_decorator (): int {.decorator. } =\n"
" retorno 42\n"
"\n"
"função echo_with_decorator ()"

#: Nim.wiki/Nim-for-Python-Programmers.md:842
msgid "Why doesn't Nim use `@decorator` syntax?."
msgstr "Por que o Nim não usa a sintaxe `@decorator`?."

#: Nim.wiki/Nim-for-Python-Programmers.md:846
msgid "Nim uses `{.` and `.}` because it can have several decorators together."
msgstr "Nim usa `{.` e`.} `porque pode ter vários decoradores juntos."

#: Nim.wiki/Nim-for-Python-Programmers.md:848
msgid "Also in Nim one works on variables and types:"
msgstr "Também no Nim, trabalha-se com variáveis e tipos:"

#: Nim.wiki/Nim-for-Python-Programmers.md:850
msgid ""
"func function_with_decorator(): int {.discardable, inline, compiletime.} =\n"
"  return 42\n"
"\n"
"let variable {.compiletime.} = 1000 / 2\n"
"\n"
"type Colors {.pure.} = enum Red, Green, Blue"
msgstr ""
"função function_with_decorator (): int {.discardable, inline, compiletime. } =\n"
" retorno 42\n"
"\n"
"deixe a variável {.compiletime.} = 1000/2\n"
"\n"
"type Colors {.pure.} = enum vermelho, verde, azul"

#: Nim.wiki/Nim-for-Python-Programmers.md:853
msgid "JSON"
msgstr "JSON"

#: Nim.wiki/Nim-for-Python-Programmers.md:854
msgid "Python uses multi-line strings with JSON inside, Nim uses literal JSON directly in the code."
msgstr "Python usa cadeias de caracteres de várias linhas com JSON interno, Nim usa JSON literal diretamente no código."

#: Nim.wiki/Nim-for-Python-Programmers.md:856
msgid ""
"import std/json\n"
"\n"
"variable = \"\"\"{\n"
"    \"key\": \"value\",\n"
"    \"other\": true\n"
"}\"\"\"\n"
"variable = json.loads(variable)\n"
"print(variable)"
msgstr ""
"importar std/json\n"
"\n"
"variável = “\" \"{\n"
" “key”: “valor”,\n"
" “outro”: verdadeiro\n"
"} \"\"”\n"
"variável = json.loads (variável)\n"
"imprimir (variável)"

#: Nim.wiki/Nim-for-Python-Programmers.md:859
msgid ""
"import json\n"
"\n"
"var variable = %*{\n"
"  \"key\": \"value\",\n"
"  \"other\": true\n"
"}\n"
"echo variable"
msgstr ""
"importar json\n"
"\n"
"variável var = %* {\n"
" “key”: “valor”,\n"
" “outro”: verdadeiro\n"
"}\n"
"variável echo"

#: Nim.wiki/Nim-for-Python-Programmers.md:862
msgid "`%*` converts everything inside the braces to JSON, JSON has a type `JsonNode`."
msgstr "`%*` converte tudo dentro dos colchetes em JSON, o JSON tem um tipo `JSONNode`."

#: Nim.wiki/Nim-for-Python-Programmers.md:865
msgid "`%*` can have variables and literals inside the braces."
msgstr "`%*` pode ter variáveis e literais dentro dos colchetes."

#: Nim.wiki/Nim-for-Python-Programmers.md:868
msgid "JSON can have Nim comments inside the braces of `%*`."
msgstr "O JSON pode ter comentários de Nim entre colchetes de `%*`."

#: Nim.wiki/Nim-for-Python-Programmers.md:871
msgid "If the JSON is not valid JSON, the code will not compile."
msgstr "Se o JSON não for um JSON válido, o código não será compilado."

#: Nim.wiki/Nim-for-Python-Programmers.md:874
msgid "`JsonNode` can be useful in Nim because is a type that can have [mixed types](https://nim-lang.github.io/Nim/manual.html#types-object-variants) and can grow/shrink."
msgstr "`JSONNode` pode ser útil no Nim porque é um tipo que pode ter [tipos mistos] (https://nim-lang.github.io/Nim/manual.html#types-object-variants) e pode crescer/encolher."

#: Nim.wiki/Nim-for-Python-Programmers.md:877
msgid "You can read JSON at compile-time, and store it in a constant as a string."
msgstr "Você pode ler o JSON em tempo de compilação e armazená-lo em uma constante como uma string."

#: Nim.wiki/Nim-for-Python-Programmers.md:880
msgid "To parse JSON from a string you can use `parseJson(\"{}\")`."
msgstr "Para analisar o JSON a partir de uma string, você pode usar `parseJSON (“{}”) `."

#: Nim.wiki/Nim-for-Python-Programmers.md:883
msgid "To parse JSON from a file use `parseFile(\"file.json\")`."
msgstr "Para analisar o JSON de um arquivo, use `parseFile (“file.json”) `."

#: Nim.wiki/Nim-for-Python-Programmers.md:886
msgid "[JSON documentation](https://nim-lang.org/docs/json.html)"
msgstr "[Documentação JSON] (https://nim-lang.org/docs/json.html)"

#: Nim.wiki/Nim-for-Python-Programmers.md:890
msgid "Self-Execution of Main Module"
msgstr "Auto-execução do módulo principal"

#: Nim.wiki/Nim-for-Python-Programmers.md:891
msgid ""
"if __name__ == \"__main__\":\n"
"  main()"
msgstr ""
"se __name__ == “__main__”:\n"
" principal ()"

#: Nim.wiki/Nim-for-Python-Programmers.md:894
msgid ""
"when is_main_module:\n"
"  main()"
msgstr ""
"quando is_main_module:\n"
" principal ()"

#: Nim.wiki/Nim-for-Python-Programmers.md:895
msgid "Unittests"
msgstr "Testes unitários"

#: Nim.wiki/Nim-for-Python-Programmers.md:896
msgid ""
"import std/unittest\n"
"\n"
"\n"
"def setUpModule():\n"
"    \"\"\"Setup: Run once before all tests in this module.\"\"\"\n"
"    pass\n"
"\n"
"def tearDownModule():\n"
"    \"\"\"Teardown: Run once after all tests in this module.\"\"\"\n"
"    pass\n"
"\n"
"\n"
"class TestName(unittest.TestCase):\n"
"    \"\"\"Test case description\"\"\"\n"
"\n"
"    def setUp(self):\n"
"        \"\"\"Setup: Run once before each tests.\"\"\"\n"
"        pass\n"
"\n"
"    def tearDown(self):\n"
"        \"\"\"Teardown: Run once after each test.\"\"\"\n"
"        pass\n"
"\n"
"    def test_example(self):\n"
"        self.assertEqual(42, 42)\n"
"\n"
"\n"
"if __name__ == \"__main__\":\n"
"    unittest.main()"
msgstr ""
"importar std/unittest\n"
"\n"
"\n"
"def setupModule ():\n"
" “\" \"Configuração: Execute uma vez antes de todos os testes neste módulo.\" \"”\n"
" passar\n"
"\n"
"def tearDownModule ():\n"
" “\" \"Teardown: Execute uma vez após todos os testes neste módulo.\" \"”\n"
" passar\n"
"\n"
"\n"
"classe TestName (UnitTest.TestCase):\n"
" “\" \"Descrição do caso de teste\" \"”\n"
"\n"
" def setUp (self):\n"
" “\" \"Configuração: Execute uma vez antes de cada teste.\" \"”\n"
" passar\n"
"\n"
" def tearDown (auto):\n"
" “\" \"Teardown: Execute uma vez após cada teste.\" \"”\n"
" passar\n"
"\n"
" def test_example (self):\n"
" A autoafirmação é igual (42, 42)\n"
"\n"
"\n"
"se __name__ == “__main__”:\n"
" unittest.main ()"

#: Nim.wiki/Nim-for-Python-Programmers.md:899
msgid ""
"import std/unittest\n"
"\n"
"suite \"Test Name\":\n"
"\n"
"  echo \"Setup: Run once before all tests in this suite.\"\n"
"\n"
"  setup:\n"
"    echo \"Setup: Run once before each test.\"\n"
"\n"
"  teardown:\n"
"    echo \"Teardown: Run once after each test.\"\n"
"\n"
"  test \"example\":\n"
"    assert 42 == 42\n"
"\n"
"  echo \"Teardown: Run once after all tests in this suite.\""
msgstr ""
"importar std/unittest\n"
"\n"
"suíte “Nome do teste”:\n"
"\n"
" echo “Configuração: Execute uma vez antes de todos os testes nesta suíte”.\n"
"\n"
" configuração:\n"
" echo “Configuração: Execute uma vez antes de cada teste”.\n"
"\n"
" desmontagem:\n"
" echo “Teardown: execute uma vez após cada teste”.\n"
"\n"
" teste “exemplo”:\n"
" afirmar 42 = 42\n"
"\n"
" echo “Teardown: execute uma vez depois de todos os testes nesta suíte”."

#: Nim.wiki/Nim-for-Python-Programmers.md:902
msgid "[Unittest documentation.](https://nim-lang.org/docs/unittest.html)"
msgstr "[Documentação do Unittest.] (https://nim-lang.org/docs/unittest.html)"

#: Nim.wiki/Nim-for-Python-Programmers.md:905
msgid "[The Nimble package manager can also run Unittests.](https://github.com/nim-lang/nimble#nimble-tasks)"
msgstr "[O gerenciador de pacotes Nimble também pode executar Unittests.] (https://github.com/nim-lang/nimble#nimble-tasks)"

#: Nim.wiki/Nim-for-Python-Programmers.md:908
msgid "[NimScript can also run Unittests.](https://nim-lang.org/docs/nims.html)"
msgstr "[O NIMScript também pode executar testes Unit.] (https://nim-lang.org/docs/nims.html)"

#: Nim.wiki/Nim-for-Python-Programmers.md:911 Nim.wiki/Nim-for-Python-Programmers.md:939
msgid "[You can run documentation as Unittests with `runnableExamples`](https://nim-lang.org/docs/system.html#runnableExamples%2Cuntyped)."
msgstr "[Você pode executar a documentação como Unittests com `RunnableExamples`] (https://nim-lang.org/docs/system.html#runnableExamples%2Cuntyped)."

#: Nim.wiki/Nim-for-Python-Programmers.md:915
msgid "Assert with customized messages"
msgstr "Assert com mensagens personalizadas"

#: Nim.wiki/Nim-for-Python-Programmers.md:918
msgid "`assert` can take a `block`. You can customize the message for better user experience:"
msgstr "`assert` pode ter um `bloco`. Você pode personalizar a mensagem para melhorar a experiência do usuário:"

#: Nim.wiki/Nim-for-Python-Programmers.md:922
msgid ""
"let a = 42\n"
"let b = 666\n"
"doAssert a == b, block:\n"
"  (\"\\nCustom Error Message!:\" &\n"
"   \"\\n  a equals to \" & $a &\n"
"   \"\\n  b equals to \" & $b)"
msgstr ""
"seja a = 42\n"
"seja b = 666\n"
"doAssert a == b, bloco:\n"
" (“\\ nMensagem de erro personalizada! :” e\n"
" “\\ n a é igual a\" & $a &\n"
" “\\ n b é igual a\" & $b)"

#: Nim.wiki/Nim-for-Python-Programmers.md:923
msgid "Testament"
msgstr "Testamento"

#: Nim.wiki/Nim-for-Python-Programmers.md:924
msgid "An alternative to `unittest`. It is prepared for big projects and has more features."
msgstr "Uma alternativa ao `unittest`. Está preparado para grandes projetos e tem mais funcionalidades."

#: Nim.wiki/Nim-for-Python-Programmers.md:928
msgid "https://nim-lang.github.io/Nim/testament.html **(Recommended)**"
msgstr "https://nim-lang.github.io/Nim/testament.html ** (Recomendado) **"

#: Nim.wiki/Nim-for-Python-Programmers.md:932
msgid "Docstrings"
msgstr "Cordas de documentos"

#: Nim.wiki/Nim-for-Python-Programmers.md:933
msgid "Docstrings in Nim are ReSTructuredText *and* MarkDown comments starting with `##`. ReSTructuredText and MarkDown can be mixed together if you want."
msgstr "Docstrings em Nim são comentários reStructuredText *e* MarkDown começando com `##`. ReStructuredText e MarkDown podem ser misturados, se você quiser."

#: Nim.wiki/Nim-for-Python-Programmers.md:935
msgid "Generate HTML, Latex (PDF) and JSON documentation from source code with `nim doc file.nim`."
msgstr "Gere documentação HTML, Latex (PDF) e JSON a partir do código-fonte com `nim doc file.nim`."

#: Nim.wiki/Nim-for-Python-Programmers.md:937
msgid "Nim can generate a dependency graph DOT `.dot` file with `nim genDepend file.nim`."
msgstr "O Nim pode gerar um gráfico de dependência DOT `.dot` com `nim GenDepend file.nim`."

#: Nim.wiki/Nim-for-Python-Programmers.md:941
msgid ""
"\"\"\"Documentation of module\"\"\"\n"
"\n"
"class Kitten(object):\n"
"    \"\"\"Documentation of class\"\"\"\n"
"\n"
"    def purr(self):\n"
"        \"\"\"Documentation of method\"\"\"\n"
"        print(\"Purr Purr\")"
msgstr ""
"“\" \"Documentação do módulo\" \"”\n"
"\n"
"classe Kitten (objeto):\n"
" “\" \"Documentação da classe\" \"”\n"
"\n"
" def purr (self):\n"
" “\" \"Documentação do método\" \"”\n"
" print (“Purr Purr”)"

#: Nim.wiki/Nim-for-Python-Programmers.md:944
msgid ""
"## Documentation of Module *ReSTructuredText* and **MarkDown**\n"
"\n"
"type Kitten = object ## Documentation of type\n"
"  age: int  ## Documentation of field\n"
"\n"
"proc purr(self: Kitten) =\n"
"  ## Documentation of function\n"
"  echo \"Purr Purr\""
msgstr ""
"## Documentação do módulo *reStructuredText* e **MarkDown**\n"
"\n"
"tipo Kitten = objeto ## Documentação do tipo\n"
" página: int ## Documentação do campo\n"
"\n"
"proc purr (self: Kitten) =\n"
" ## Documentação da função\n"
" eco “Purr Purr”"

#: Nim.wiki/Nim-for-Python-Programmers.md:945
msgid "Optional Indentation"
msgstr "Indentação opcional"

#: Nim.wiki/Nim-for-Python-Programmers.md:946
msgid "You can write constructs like `if..then` and `try..except..finally` on a single line without errors or warnings; indentation is optional. Obviously, this is only a good idea if the snippet is short and simple."
msgstr "Você pode escrever construções como `if.. then` e `try.. except.. finally` em uma única linha sem erros ou avisos; a indentação é opcional. Obviamente, isso só é uma boa ideia se o trecho for curto e simples."

#: Nim.wiki/Nim-for-Python-Programmers.md:948
msgid ""
"let a = try: 1 + 2 except: 42 finally: echo \"Inline try\"\n"
"\n"
"let b = if true: 2 / 4 elif false: 4 * 2 else: 0\n"
"\n"
"for i in 0 .. 9: echo i\n"
"\n"
"proc foo() = echo \"Function\"\n"
"\n"
"(proc   () = echo \"Anonymous function\")()\n"
"\n"
"template bar() = echo \"Template\"\n"
"\n"
"macro baz() = echo \"Macro\"\n"
"\n"
"var i = 0\n"
"while i < 9: i += 1\n"
"\n"
"when is_main_module: echo 42"
msgstr ""
"deixe a = try: 1 + 2 exceto: 42 finalmente: echo “Inline try”\n"
"\n"
"seja b = se verdadeiro: 2/4 elif falso: 4 * 2 senão: 0\n"
"\n"
"para i em 0.9.9: echo i\n"
"\n"
"proc foo () = echo “Função”\n"
"\n"
"(proc () = echo “Função anônima”) ()\n"
"\n"
"barra de modelo () = echo “Modelo”\n"
"\n"
"macro baz () = echo “Macro”\n"
"\n"
"var i = 0\n"
"enquanto i < 9: i += 1\n"
"\n"
"quando is_main_module: echo 42"

#: Nim.wiki/Nim-for-Python-Programmers.md:949
msgid "CamelCase"
msgstr "Estojo Camel"

#: Nim.wiki/Nim-for-Python-Programmers.md:952
msgid "Why is Nim CamelCase instead of snake_case?."
msgstr "Por que Nim CamelCase em vez de snake_case?."

#: Nim.wiki/Nim-for-Python-Programmers.md:956
msgid "It really isn't, Nim is style-agnostic!"
msgstr "Realmente não é, Nim é independente de estilo!"

#: Nim.wiki/Nim-for-Python-Programmers.md:958
msgid ""
"let camelCase = 42      # Declaring as camelCase \n"
"assert camel_case == 42 # Using as snake_case\n"
"\n"
"let snake_case = 1      # Declaring as snake_case\n"
"assert snakeCase == 1   # Using as camelCase\n"
"\n"
"let `free style` = 9000\n"
"assert free_style == 9000  "
msgstr ""
"let camelCase = 42 # Declarando como camelCase \n"
"assert camel_case == 42 # Usando como snake_case\n"
"\n"
"let snake_case = 1 # Declarando como snake_case\n"
"assert SnakeCase == 1 # Usando como CamelCase\n"
"\n"
"deixe `estilo livre` = 9000\n"
"assert free_style = 900  "

#: Nim.wiki/Nim-for-Python-Programmers.md:959
msgid "**This feature allows Nim to seamlessly interoperate with a lot of programming languages with different casing styles.**"
msgstr "**Esse recurso permite que o Nim interopere perfeitamente com várias linguagens de programação com diferentes estilos de revestimento. **"

#: Nim.wiki/Nim-for-Python-Programmers.md:961
msgid "For more homogeneous code you can enforce a default casing style using the compiler command `--styleCheck:hint`. Nim will *style check* your code before compilation, similar to `pycodestyle` in Python. If you want even more strict styling you can use `--styleCheck:error`."
msgstr "Para obter um código mais homogêneo, você pode aplicar um estilo de caixa padrão usando o comando do compilador `—styleCheck:hint`. Nim *verificará o estilo* seu código antes da compilação, semelhante ao `pycodestyle` em Python. Se você quiser um estilo ainda mais rígido, você pode usar `—styleCheck:error`."

#: Nim.wiki/Nim-for-Python-Programmers.md:963
msgid "Nim comes with a builtin code auto-formatter named Nimpretty."
msgstr "O Nim vem com um formatador automático de código embutido chamado Nimpretty."

#: Nim.wiki/Nim-for-Python-Programmers.md:965
msgid ""
"A lot of programming languages have some kind of case-insensitivity, such as:\n"
"PowerShell, SQL, PHP, Lisp, Assembly, Batch, ABAP, Ada, Visual Basic, VB.NET, Fortran, Pascal, Forth, Cobol, Scheme, Red, Rebol."
msgstr ""
"Muitas linguagens de programação não diferenciam maiúsculas e minúsculas, como:\n"
"PowerShell, SQL, PHP, Lisp, Montagem, Lote, ABAP, Ada, Visual Basic, VB.NET, Fortran, Pascal, Forth, Cobol, Esquema, Vermelho, Rebol."

#: Nim.wiki/Nim-for-Python-Programmers.md:967
msgid "If you are just starting from scratch, you can use Python-like names while learning. It will not produce an error unless you tell the compiler you want that."
msgstr "Se você está começando do zero, pode usar nomes semelhantes aos do Python enquanto aprende. Isso não produzirá um erro, a menos que você diga ao compilador que deseja isso."

#: Nim.wiki/Nim-for-Python-Programmers.md:969
msgid "def vs proc/func"
msgstr "def versus proc/func"

#: Nim.wiki/Nim-for-Python-Programmers.md:972
msgid "Why doesn't Nim use `def` instead of `proc`?."
msgstr "Por que Nim não usa `def` em vez de `proc`?."

#: Nim.wiki/Nim-for-Python-Programmers.md:976
msgid "Nim uses `proc` for normal functions, which is short for \"procedure\"."
msgstr "Nim usa `proc` para funções normais, que é a abreviação de “procedimento”."

#: Nim.wiki/Nim-for-Python-Programmers.md:978
msgid "Use `func` for when your routine cannot and should not access global or thread-local variables (see also: [pure functions](https://en.wikipedia.org/wiki/Pure_function))."
msgstr "Use `func` para quando sua rotina não puder e não deve acessar variáveis globais ou locais de encadeamento (veja também: [funções puras] (https://en.wikipedia.org/wiki/Pure_function))."

#: Nim.wiki/Nim-for-Python-Programmers.md:980
msgid "[Nim has side-effects tracking.](https://nim-lang.github.io/Nim/manual.html#procedures-func)"
msgstr "[Nim tem rastreamento de efeitos colaterais.] (https://nim-lang.github.io/Nim/manual.html#procedures-func)"

#: Nim.wiki/Nim-for-Python-Programmers.md:982
msgid "You can not use `echo` inside `func`, because `echo` mutates `stdout`, which is a side-effect. Use `debugEcho` instead."
msgstr "Você não pode usar `echo` dentro de `func`, porque `echo` muda `stdout`, o que é um efeito colateral. Em vez disso, use `DebugeCho`."

#: Nim.wiki/Nim-for-Python-Programmers.md:988
msgid "[Strict Func](https://nim-lang.github.io/Nim/manual_experimental.html#strict-funcs)"
msgstr "[Fundo estrito] (https://nim-lang.github.io/Nim/manual_experimental.html#strict-funcs)"

#: Nim.wiki/Nim-for-Python-Programmers.md:991
msgid "[Write Tracking for Nim](https://nim-lang.org/araq/writetracking_2.html)"
msgstr "[Rastreamento de gravação para Nim] (https://nim-lang.org/araq/writetracking_2.html)"

#: Nim.wiki/Nim-for-Python-Programmers.md:995
msgid "If you are just starting from scratch, you can use `proc` for all the functions while learning. It will not produce an error for doing so."
msgstr "Se você está começando do zero, você pode usar `proc` para todas as funções enquanto aprende. Isso não produzirá um erro ao fazer isso."

#: Nim.wiki/Nim-for-Python-Programmers.md:997
msgid "Async"
msgstr "Assíncrono"

#: Nim.wiki/Nim-for-Python-Programmers.md:998
msgid "Nim has had async built-in for a long time. It works as you may expect with `async`, `await`, `Future`, etc."
msgstr "O Nim tem a assíncrona embutida há muito tempo. Funciona como você pode esperar com `async`, `await`, `Future`, etc."

#: Nim.wiki/Nim-for-Python-Programmers.md:1000
msgid "[asyncdispatch](https://nim-lang.org/docs/asyncdispatch.html) is a module to write concurrent code using the `async`/`await` syntax."
msgstr "[asyncdispatch] (https://nim-lang.org/docs/asyncdispatch.html) é um módulo para escrever código simultâneo usando a sintaxe `async`/`await`."

#: Nim.wiki/Nim-for-Python-Programmers.md:1002
msgid "`Future` is a type (like a Future in Python, or a Promise in JavaScript)."
msgstr "`Future` é um tipo (como um futuro em Python ou uma promessa em JavaScript)."

#: Nim.wiki/Nim-for-Python-Programmers.md:1004
msgid "`{.async.}` is a pragma that converts functions to async (like `async def` in Python)."
msgstr "`{.async.}` é um pragma que converte funções em assíncronas (como `async def` em Python)."

#: Nim.wiki/Nim-for-Python-Programmers.md:1006
msgid "Let's convert the official Python asyncio *Hello World* to Nim:"
msgstr "Vamos converter o asíncio oficial do Python *Hello World* para Nim:"

#: Nim.wiki/Nim-for-Python-Programmers.md:1008
msgid ""
"async def main():\n"
"    print(\"Hello ...\")\n"
"    await asyncio.sleep(1)\n"
"    print(\"... World!\")\n"
"\n"
"asyncio.run(main())"
msgstr ""
"async def main ():\n"
" imprimir (“Olá...”)\n"
" aguarde asyncio.sleep (1)\n"
" imprimir (“... Mundo!”)\n"
"\n"
"asynio.run (main ()"

#: Nim.wiki/Nim-for-Python-Programmers.md:1011
msgid ""
"proc main() {.async.} =\n"
"  echo(\"Hello ...\")\n"
"  await sleep_async(1)\n"
"  echo(\"... World!\")\n"
"\n"
"wait_for main()"
msgstr ""
"proc main () {.async. } =\n"
" echo (“Olá...”)\n"
" aguarde sleep_async (1)\n"
" eco (“... Mundo!”)\n"
"\n"
"wait_for main ()"

#: Nim.wiki/Nim-for-Python-Programmers.md:1012
msgid "Internally async is implemented using metaprogramming (macros, templates, pragmas, etc)."
msgstr "A assíncrona interna é implementada usando metaprogramação (macros, modelos, pragmas, etc.)."

#: Nim.wiki/Nim-for-Python-Programmers.md:1017
msgid "Why doesn't Nim use `async def`?."
msgstr "Por que Nim não usa `async def`?."

#: Nim.wiki/Nim-for-Python-Programmers.md:1021
msgid "Async is just a `macro` in Nim, no need to change the syntax of the language. It is like a decorator in Python, only more powerful."
msgstr "Async é apenas uma `macro` em Nim, sem necessidade de alterar a sintaxe da linguagem. É como um decorador em Python, só que mais poderoso."

#: Nim.wiki/Nim-for-Python-Programmers.md:1023
msgid "Also in Nim the same function can be asynchronous *and* synchronous at the same time, with the same code, with the same name."
msgstr "Também no Nim, a mesma função pode ser assíncrona *e* síncrona ao mesmo tempo, com o mesmo código, com o mesmo nome."

#: Nim.wiki/Nim-for-Python-Programmers.md:1025
msgid "In Python when you have a library *\"foo\"*, you may need both `foo` (sync) and `aiofoo` (async), which are usually completely different projects, repos, developers and APIs. This is not needed in Nim, or rarely seen, thanks to said feature."
msgstr "Em Python, quando você tem uma biblioteca *\"foo\"*, você pode precisar de `foo` (sync) e `aiofoo` (async), que geralmente são projetos, repositórios, desenvolvedores e APIs completamente diferentes. Isso não é necessário no Nim, ou raramente visto, graças a esse recurso."

#: Nim.wiki/Nim-for-Python-Programmers.md:1027
msgid "[Because async is just a `macro` in Nim you can create your own async your way too.](https://github.com/disruptek/cps#why)"
msgstr "[Como o async é apenas uma `macro` no Nim, você também pode criar seu próprio assíncrono do seu jeito.] (https://github.com/disruptek/cps#why)"

#: Nim.wiki/Nim-for-Python-Programmers.md:1029
msgid ""
"See also [asyncfile](https://nim-lang.org/docs/asyncfile.html), \n"
"[asyncnet](https://nim-lang.org/docs/asyncnet.html), \n"
"[asyncstreams](https://nim-lang.org/docs/asyncstreams.html), \n"
"[asyncftpclient](https://nim-lang.org/docs/asyncftpclient.html),\n"
"[asyncfutures](https://nim-lang.org/docs/asyncfutures.html)."
msgstr ""
"Veja também [asyncfile] (https://nim-lang.org/docs/asyncfile.html), \n"
"[asyncnet] (https://nim-lang.org/docs/asyncnet.html), \n"
"[fluxos assíncronos] (https://nim-lang.org/docs/asyncstreams.html), \n"
"[cliente de ftp async] (https://nim-lang.org/docs/asyncftpclient.html),\n"
"[asyncfutures] (https://nim-lang.org/docs/asyncfutures.html)."

#: Nim.wiki/Nim-for-Python-Programmers.md:1031
msgid "Do I have to know C?"
msgstr "Eu tenho que conhecer C?"

#: Nim.wiki/Nim-for-Python-Programmers.md:1032
msgid "You never have to actually manually edit C, the same way in Python you never manually edit the .pyc files."
msgstr "Você nunca precisa realmente editar manualmente o C, da mesma forma que no Python você nunca edita manualmente os arquivos .pyc."

#: Nim.wiki/Nim-for-Python-Programmers.md:1034
msgid "In Nim you code by writing Nim, the same way in Python you code by writing Python."
msgstr "No Nim, você codifica escrevendo Nim, da mesma forma que em Python você codifica escrevendo Python."

#: Nim.wiki/Nim-for-Python-Programmers.md:1036
msgid "Templates"
msgstr "Modelos"

#: Nim.wiki/Nim-for-Python-Programmers.md:1037
msgid "A template replaces its invocation with the template body at compile-time."
msgstr "Um modelo substitui sua invocação pelo corpo do modelo em tempo de compilação."

#: Nim.wiki/Nim-for-Python-Programmers.md:1039
msgid "Essentially, **the compiler will copy and paste a chunk of code for you**."
msgstr "Essencialmente, **o compilador copiará e colará um pedaço de código para você**."

#: Nim.wiki/Nim-for-Python-Programmers.md:1041
msgid ""
"A template allows us to have a function-like constructs without any overhead, or\n"
"to split huge functions into smaller parts."
msgstr ""
"Um modelo nos permite ter construções semelhantes a uma função sem qualquer sobrecarga, ou\n"
"para dividir grandes funções em partes menores."

#: Nim.wiki/Nim-for-Python-Programmers.md:1043
msgid ""
"Too many function and variable names may pollute the local namespace.\n"
"Variables inside templates do not exist outside of their template.\n"
"Templates do not exist in the namespace at run-time (if you do not export them),\n"
"Templates may optimize certain values if they are known at compile-time."
msgstr ""
"Muitos nomes de funções e variáveis podem poluir o namespace local.\n"
"As variáveis dentro dos modelos não existem fora do modelo.\n"
"Os modelos não existem no namespace em tempo de execução (se você não os exportar),\n"
"Os modelos podem otimizar determinados valores se forem conhecidos em tempo de compilação."

#: Nim.wiki/Nim-for-Python-Programmers.md:1045
msgid "Templates *cannot* do `import` nor `export` of libraries automatically implicitly. Templates do *not* \"auto-import\" symbols used inside itself. If you use any imported library on the body of a template, you must import that library when invoking that template."
msgstr "Os templates *não* podem `importar` nem `exportar` de bibliotecas automaticamente implicitamente. Os modelos *não* “importam automaticamente” símbolos usados dentro de si mesmos. Se você usar qualquer biblioteca importada no corpo de um modelo, deverá importar essa biblioteca ao invocar esse modelo."

#: Nim.wiki/Nim-for-Python-Programmers.md:1047
msgid "Inside templates you can not use `return` because a template is not a function."
msgstr "Dentro dos modelos, você não pode usar `return` porque um modelo não é uma função."

#: Nim.wiki/Nim-for-Python-Programmers.md:1049
msgid "Templates allow you to implement very high-level, beautiful APIs for everyday usage, while keeping the low-level optimized details out of your head and [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)."
msgstr "Os modelos permitem que você implemente APIs bonitas e de alto nível para o uso diário, mantendo os detalhes otimizados de baixo nível fora de sua cabeça e [DRY] (https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)."

#: Nim.wiki/Nim-for-Python-Programmers.md:1051
msgid "Python `with open(\"file.txt\", mode = \"r\") as file:` implemented using a template:"
msgstr "Python `com open (” file.txt “, mode = “r”) como arquivo: `implementado usando um modelo:"

#: Nim.wiki/Nim-for-Python-Programmers.md:1053
msgid "[![Template explanation animation](https://raw.githubusercontent.com/juancarlospaco/nim-presentation-slides/master/templates.gif \"Template explanation animation\")](https://github.com/juancarlospaco/nim-presentation-slides/blob/master/templates.xcf)"
msgstr "[! [Animação explicativa do modelo] (https://raw.githubusercontent.com/juancarlospaco/nim-presentation-slides/master/templates.gif “Animação explicativa do modelo”)] (https://github.com/juancarlospaco/nim-presentation-slides/blob/master/templates.xcf)"

#: Nim.wiki/Nim-for-Python-Programmers.md:1055
msgid "The GIF is not perfect, but a lazy simplified approximation! "
msgstr "O GIF não é perfeito, mas uma aproximação preguiçosa e simplificada! "

#: Nim.wiki/Nim-for-Python-Programmers.md:1057
msgid "This is not the way to read files in Nim, just an exercise."
msgstr "Essa não é a maneira de ler arquivos no Nim, apenas um exercício."

#: Nim.wiki/Nim-for-Python-Programmers.md:1059
msgid "This template is not perfect, but a lazy approximation. It is an exercise for the reader to try to improve it ;P"
msgstr "Este modelo não é perfeito, mas uma aproximação preguiçosa. É um exercício para o leitor tentar melhorá-lo; P"

#: Nim.wiki/Nim-for-Python-Programmers.md:1061
msgid ""
"template withOpen(name: string, mode: char, body: untyped) =\n"
"  let flag = if mode == 'w': fmWrite else: fmRead  # \"flag\" doen't exist outside of this template\n"
"  let file {.inject.} = open(name, flag)   # Create and inject `file` variable, `file` exists outside of this template because of {.inject.}\n"
"  try:\n"
"    body                                   # `body` is the code passed as argument\n"
"  finally:\n"
"    file.close()                           # Code after the code passed as argument\n"
"\n"
"withOpen(\"testing.nim\", 'r'): # Mimic Python with `open(\"file\", mode='r') as file`\n"
"  echo \"Hello Templates\"      # Code inside the template, this 2 lines are \"body\" argument on the template\n"
"  echo file.read_all()        # This line uses \"file\" variable"
msgstr ""
"template withOpen (nome: string, modo: char, corpo: sem tipo) =\n"
" let flag = if mode == 'w': fmWrite else: fmRead # “flag” não existe fora deste modelo\n"
" let file {.inject.} = open (nome, bandeira) # Crie e injete a variável `file`, `file` existe fora deste modelo por causa de {.inject.}\n"
" tente:\n"
" body # `body` é o código passado como argumento\n"
" finalmente:\n"
" file.close () # Código após o código passado como argumento\n"
"\n"
"withOpen (“testing.nim”, 'r'): # Imite o Python com `open (“file”, mode='r') como arquivo`\n"
" echo “Hello Templates” # Código dentro do modelo, essas 2 linhas são o argumento “corpo” no modelo\n"
" echo file.read_all () # Esta linha usa a variável “arquivo”"

#: Nim.wiki/Nim-for-Python-Programmers.md:1062
msgid "If you are just starting from scratch, do not worry, you can use functions for everything while learning."
msgstr "Se você está começando do zero, não se preocupe, você pode usar funções para tudo enquanto aprende."

#: Nim.wiki/Nim-for-Python-Programmers.md:1064
msgid "How to share variables between functions?"
msgstr "Como compartilhar variáveis entre funções?"

#: Nim.wiki/Nim-for-Python-Programmers.md:1065
msgid "Sharing variables between functions is similar to Python."
msgstr "O compartilhamento de variáveis entre funções é semelhante ao Python."

#: Nim.wiki/Nim-for-Python-Programmers.md:1067
msgid "**Global variable:**"
msgstr "**Variável global: **"

#: Nim.wiki/Nim-for-Python-Programmers.md:1069
msgid ""
"global_variable = \"\"\n"
"\n"
"def function0():\n"
"    global global_variable\n"
"    global_variable = \"cat\"\n"
"\n"
"def function1():\n"
"    global global_variable\n"
"    global_variable = \"dog\"\n"
"\n"
"function0()\n"
"assert global_variable == \"cat\"\n"
"function1()\n"
"assert global_variable == \"dog\"\n"
"function0()\n"
"assert global_variable == \"cat\""
msgstr ""
"global_variable = “”\n"
"\n"
"função def (0):\n"
" variável global_global\n"
" global_variable = “gato”\n"
"\n"
"função def 1 ():\n"
" variável global_global\n"
" global_variable = “cachorro”\n"
"\n"
"função (0)\n"
"assert global_variable == “cat”\n"
"função (1)\n"
"assert global_variable == “cachorro”\n"
"função (0)\n"
"assert global_variable == “cat”"

#: Nim.wiki/Nim-for-Python-Programmers.md:1072
msgid ""
"var global_variable = \"\"\n"
"\n"
"proc function0() =\n"
"  global_variable = \"cat\"\n"
"\n"
"proc function1() =\n"
"  global_variable = \"dog\"\n"
"\n"
"function0()\n"
"assert global_variable == \"cat\"\n"
"function1()\n"
"assert global_variable == \"dog\"\n"
"function0()\n"
"assert global_variable == \"cat\""
msgstr ""
"var global_variable = “”\n"
"\n"
"função proc (0) =\n"
" global_variable = “gato”\n"
"\n"
"função proc (1) =\n"
" global_variable = “cachorro”\n"
"\n"
"função (0)\n"
"assert global_variable == “cat”\n"
"função (1)\n"
"assert global_variable == “cachorro”\n"
"função (0)\n"
"assert global_variable == “cat”"

#: Nim.wiki/Nim-for-Python-Programmers.md:1073
msgid "**Object Attribute:**"
msgstr "**Atributo do objeto: **"

#: Nim.wiki/Nim-for-Python-Programmers.md:1075
msgid ""
"class IceCream:\n"
"\n"
"  def __init__(self):\n"
"    self.object_attribute = None\n"
"\n"
"def function_a(food):\n"
"    food.object_attribute = 9\n"
"\n"
"def function_b(food):\n"
"    food.object_attribute = 5\n"
"\n"
"food = IceCream()\n"
"function_a(food)\n"
"assert food.object_attribute == 9\n"
"function_b(food)\n"
"assert food.object_attribute == 5\n"
"function_a(food)\n"
"assert food.object_attribute == 9"
msgstr ""
"classe IceCream:\n"
"\n"
" def __init__ (self):\n"
" self.object_attribute = Nenhum\n"
"\n"
"def function_a (comida):\n"
" food.object_attribute = 9\n"
"\n"
"def function_b (comida):\n"
" food.object_attribute = 5\n"
"\n"
"comida = sorvete ()\n"
"função_a (comida)\n"
"assert food.object_attribute = 9\n"
"função_b (comida)\n"
"assert food.object_attribute = 5\n"
"função_a (comida)\n"
"assert food.object_attribute = 9"

#: Nim.wiki/Nim-for-Python-Programmers.md:1078
msgid ""
"type IceCream = object\n"
"  object_attribute: int\n"
"\n"
"proc functiona(food: var IceCream) =\n"
"  food.object_attribute = 9\n"
"\n"
"proc functionb(food: var IceCream) =\n"
"  food.object_attribute = 5\n"
"\n"
"var food = IceCream()\n"
"functiona(food)\n"
"assert food.object_attribute == 9\n"
"functionb(food)\n"
"assert food.object_attribute == 5\n"
"functiona(food)\n"
"assert food.object_attribute == 9"
msgstr ""
"tipo IceCream = objeto\n"
" object_attribute: int\n"
"\n"
"função do produto (comida: sorvete) =\n"
" food.object_attribute = 9\n"
"\n"
"função proc (comida: var IceCream) =\n"
" food.object_attribute = 5\n"
"\n"
"var food = IceCream ()\n"
"funcional (comida)\n"
"assert food.object_attribute = 9\n"
"função b (comida)\n"
"assert food.object_attribute = 5\n"
"funcional (comida)\n"
"assert food.object_attribute = 9"

#: Nim.wiki/Nim-for-Python-Programmers.md:1079
msgid "You can pass functions as arguments to other functions like in Python. Functions (procs) are first class objects."
msgstr "Você pode passar funções como argumentos para outras funções, como em Python. Funções (procs) são objetos de primeira classe."

#: Nim.wiki/Nim-for-Python-Programmers.md:1081
msgid "In-Place vs Out-Place"
msgstr "No local versus fora do local"

#: Nim.wiki/Nim-for-Python-Programmers.md:1082
msgid "If you are migrating from an interpreted language, like Python or JavaScript, you may find strange mentions of \"In-Place\" and \"Out-Place\" somewhere in Nim. If you don't know what it means then Nim looks like it has duplicated functions."
msgstr "Se você estiver migrando de uma linguagem interpretada, como Python ou JavaScript, você pode encontrar menções estranhas de “In-Place” e “Out-Place” em algum lugar de Nim. Se você não sabe o que isso significa, parece que o Nim tem funções duplicadas."

#: Nim.wiki/Nim-for-Python-Programmers.md:1084
msgid ""
"Python allocates a new string or object when something in it changes somehow. Let's say you have a huge string in a variable and you want to change a single character. Since Python strings are immutable, the only solution is to duplicate the string in memory but with the new copy having that character changed. Returning a new copy "
"is an \"Out-Place\" operation. Most of Python works like this."
msgstr ""
"O Python aloca uma nova string ou objeto quando algo nele muda de alguma forma. Digamos que você tenha uma sequência enorme em uma variável e queira alterar um único caractere. Como as cadeias de caracteres do Python são imutáveis, a única solução é duplicar a string na memória, mas com a nova cópia tendo esse caractere alterado. "
"Devolver uma nova cópia é uma operação “Out-Place”. A maior parte do Python funciona assim."

#: Nim.wiki/Nim-for-Python-Programmers.md:1086
msgid "On the other hand, Nim's strings are mutable. In Nim you can change only the character you want to change, rather than copying the string in memory. Some functions work in-place, some functions work on a new copy. The documentation will (usually) which."
msgstr "Por outro lado, as cordas de Nim são mutáveis. No Nim, você pode alterar apenas o caractere que deseja alterar, em vez de copiar a string na memória. Algumas funções funcionam no local, outras funcionam em uma nova cópia. A documentação (geralmente) será qual."

#: Nim.wiki/Nim-for-Python-Programmers.md:1088
msgid "[using `macro` Nim can turn from an in-place function to out-place one.](https://nim-lang.github.io/Nim/sugar.html#dup.m%2CT%2Cvarargs%5Buntyped%5D)"
msgstr "[usando `macro`, o Nim pode passar de uma função no local para uma externa.] (https://nim-lang.github.io/Nim/sugar.html#dup.m%2CT%2Cvarargs%5Buntyped%5D)"

#: Nim.wiki/Nim-for-Python-Programmers.md:1090
msgid "Nim stdlib modules designed for the JavaScript target usually work on a new copy. This is just how the JavaScript target is; there is no in-place API nor benefits from using it."
msgstr "Os módulos Nim stdlib projetados para o destino JavaScript geralmente funcionam em uma nova cópia. É assim que o destino do JavaScript é; não há API local nem benefícios em usá-la."

#: Nim.wiki/Nim-for-Python-Programmers.md:1092
msgid "Some Nim stdlib modules that work on a new copy may or may not be changed to work in-place in the future."
msgstr "Alguns módulos Nim stdlib que funcionam em uma nova cópia podem ou não ser alterados para funcionar no local no futuro."

#: Nim.wiki/Nim-for-Python-Programmers.md:1094
msgid "Examples:"
msgstr "Exemplos:"

#: Nim.wiki/Nim-for-Python-Programmers.md:1096
msgid ""
"import std/sugar  # sugar.dup\n"
"\n"
"func inplace_function(s: var string) =  # Does not use \"string\" but \"var string\"\n"
"  s = \"CHANGED\"\n"
"\n"
"# In-Place algo.\n"
"var bar = \"in-place\"\n"
"inplace_function(bar)  ## Variable mutated in-place.\n"
"assert bar == \"CHANGED\"\n"
"\n"
"# Out-Place algo.\n"
"assert \"out-place\".dup(inplace_function) == \"CHANGED\"  ## Variable mutated on a new copy."
msgstr ""
"importar std/sugar # sugar.dup\n"
"\n"
"func inplace_function (s: var string) = # Não usa “string”, mas “var string”\n"
" s = “ALTERADO”\n"
"\n"
"# Logotipo no local.\n"
"var bar = “no local”\n"
"inplace_function (bar) ## Variável mutada no local.\n"
"barra de assert == “ALTERADO”\n"
"\n"
"# Logotipo externo.\n"
"assert “out-place” .dup (inplace_function) == “CHANGED” ## Variável modificada em uma nova cópia."

#: Nim.wiki/Nim-for-Python-Programmers.md:1097
msgid "Import Nim files in Python"
msgstr "Importar arquivos Nim em Python"

#: Nim.wiki/Nim-for-Python-Programmers.md:1100
msgid "https://github.com/Pebaz/nimporter#nimporter"
msgstr "https://github.com/Pebaz/nimporter#nimporter"

#: Nim.wiki/Nim-for-Python-Programmers.md:1104
msgid "Python Syntax for Nim"
msgstr "Sintaxe Python para Nim"

#: Nim.wiki/Nim-for-Python-Programmers.md:1107
msgid "https://github.com/Yardanico/nimpylib#nimpylib"
msgstr "https://github.com/Yardanico/nimpylib#nimpylib"

#: Nim.wiki/Nim-for-Python-Programmers.md:1111
msgid "Publish to PYPI"
msgstr "Publicar no PYPI"

#: Nim.wiki/Nim-for-Python-Programmers.md:1114
msgid "https://github.com/yglukhov/nimpy/wiki#publish-to-pypi"
msgstr "https://github.com/yglukhov/nimpy/wiki#publish-to-pypi"

#: Nim.wiki/Nim-for-Python-Programmers.md:1117
msgid "https://github.com/sstadick/ponim/blob/master/README.md#nim--python--poetry--"
msgstr "https://github.com/sstadick/ponim/blob/master/README.md#nim--python--poetry —"

#: Nim.wiki/Nim-for-Python-Programmers.md:1120
msgid "https://github.com/sstadick/nython#nython"
msgstr "https://github.com/sstadick/nython#nython"

#: Nim.wiki/Nim-for-Python-Programmers.md:1124
msgid "Silent Compilation"
msgstr "Compilação silenciosa"

#: Nim.wiki/Nim-for-Python-Programmers.md:1125
msgid ""
"If you want the compilation to be completely silent (you may miss important warnings and hints), \n"
"you can add to the compile command ` --hints:off --verbosity:0 `."
msgstr ""
"Se você quiser que a compilação fique completamente silenciosa (você pode perder avisos e dicas importantes), \n"
"você pode adicionar ao comando de compilação `—hints:off —verbosity:0`."

#: Nim.wiki/Nim-for-Python-Programmers.md:1127
msgid "Compiler Help"
msgstr "Ajuda do compilador"

#: Nim.wiki/Nim-for-Python-Programmers.md:1128
msgid "The compiler help is long. To make it more user friendly only the most frequent commands are shown with `--help`. If you want to see the full help you can use `--fullhelp`."
msgstr "A ajuda do compilador é longa. Para torná-lo mais fácil de usar, apenas os comandos mais frequentes são mostrados com `—help`. Se você quiser ver a ajuda completa, você pode usar `—fullhelp`."

#: Nim.wiki/Nim-for-Python-Programmers.md:1130
msgid "Build Modes"
msgstr "Modos de construção"

#: Nim.wiki/Nim-for-Python-Programmers.md:1131
msgid ""
"When your code is ready for production you should use a Release build,\n"
"you can add to the compile command ` -d:release `."
msgstr ""
"Quando seu código estiver pronto para produção, você deve usar uma versão Release,\n"
"você pode adicionar ao comando de compilação `-d:release`."

#: Nim.wiki/Nim-for-Python-Programmers.md:1134
msgid "MicroPython"
msgstr "MicroPython"

#: Nim.wiki/Nim-for-Python-Programmers.md:1135
msgid "Nim compiles to C, so it can run on Arduino and similar hardware."
msgstr "O Nim compila em C, para que possa ser executado no Arduino e em hardware similar."

#: Nim.wiki/Nim-for-Python-Programmers.md:1137
msgid ""
"Has several memory management strategies to fit your needs, including full manual memory management.\n"
"Nim binaries are small when built for Release and it can fit the hardware tiny storage."
msgstr ""
"Tem várias estratégias de gerenciamento de memória para atender às suas necessidades, incluindo gerenciamento manual completo da memória.\n"
"Os binários Nim são pequenos quando construídos para o Release e podem caber no pequeno armazenamento do hardware."

#: Nim.wiki/Nim-for-Python-Programmers.md:1141
msgid "https://github.com/zevv/nim-arduino"
msgstr "https://github.com/zevv/nim-arduino"

#: Nim.wiki/Nim-for-Python-Programmers.md:1144
msgid "https://github.com/elcritch/nesper#example-code"
msgstr "https://github.com/elcritch/nesper#example-code"

#: Nim.wiki/Nim-for-Python-Programmers.md:1147
msgid "https://gitlab.com/endes123321/nimcdl/tree/master#nimcdl-nim-circuit-design-language"
msgstr "https://gitlab.com/endes123321/nimcdl/tree/master#nimcdl-nim-circuit-design-language"

#: Nim.wiki/Nim-for-Python-Programmers.md:1150
msgid "https://github.com/cfvescovo/Arduino-Nim#arduino-nim"
msgstr "https://github.com/cfvescovo/Arduino-Nim#arduino-nim"

#: Nim.wiki/Nim-for-Python-Programmers.md:1153
msgid "https://gitlab.com/nimbed/nimbed#nimbed"
msgstr "https://gitlab.com/nimbed/nimbed#nimbed"

#: Nim.wiki/Nim-for-Python-Programmers.md:1156
msgid "https://gitlab.com/endes123321/led-controller-frontend#led-controller-frontend"
msgstr "https://gitlab.com/endes123321/led-controller-frontend#led-controller-frontend"

#: Nim.wiki/Nim-for-Python-Programmers.md:1159
msgid "https://gitlab.com/jalexander8717/msp430f5510-nim"
msgstr "https://gitlab.com/jalexander8717/msp430f5510-nim"

#: Nim.wiki/Nim-for-Python-Programmers.md:1162
msgid "https://github.com/mwbrown/nim_stm32f3"
msgstr "https://github.com/mwbrown/nim_stm32f3"

#: Nim.wiki/Nim-for-Python-Programmers.md:1165
msgid "https://github.com/gokr/ardunimo"
msgstr "https://github.com/gokr/ardunimo"

#: Nim.wiki/Nim-for-Python-Programmers.md:1168
msgid "https://gitlab.com/NetaLabTek/Arduimesp"
msgstr "https://gitlab.com/NetaLabTek/Arduimesp"

#: Nim.wiki/Nim-for-Python-Programmers.md:1171
msgid "https://ftp.heanet.ie/mirrors/fosdem-video/2020/AW1.125/nimoneverything.webm"
msgstr "https://ftp.heanet.ie/mirrors/fosdem-video/2020/AW1.125/nimoneverything.webm"

#: Nim.wiki/Nim-for-Python-Programmers.md:1175
msgid "SuperCollider"
msgstr "SuperCollider"

#: Nim.wiki/Nim-for-Python-Programmers.md:1176
msgid "SuperCollider is C++ so it can be re-utilized using Nim."
msgstr "O SuperCollider é C++, então ele pode ser reutilizado usando o Nim."

#: Nim.wiki/Nim-for-Python-Programmers.md:1178
msgid ""
"Theoretically, Nim SuperCollider plugins should be just as fast as C code.\n"
"Nim's metaprogramming allows us to build LiveCoding friendly DSLs."
msgstr ""
"Teoricamente, os plug-ins do Nim SuperCollider devem ser tão rápidos quanto o código C.\n"
"A metaprogramação de Nim nos permite criar DSLs compatíveis com LiveCoding."

#: Nim.wiki/Nim-for-Python-Programmers.md:1180
msgid "Some projects for Nim LiveCoding:"
msgstr "Alguns projetos para o Nim LiveCoding:"

#: Nim.wiki/Nim-for-Python-Programmers.md:1184
msgid "https://github.com/vitreo12/omni#omni"
msgstr "https://github.com/vitreo12/omni#omni"

#: Nim.wiki/Nim-for-Python-Programmers.md:1187
msgid "https://github.com/capocasa/scnim#scnim---writing-supercollider-ugens-using-nim"
msgstr "https://github.com/capocasa/scnim#scnim---writing-supercollider-ugens-using-nim"

#: Nim.wiki/Nim-for-Python-Programmers.md:1191
msgid "ABC"
msgstr "ABC"

#: Nim.wiki/Nim-for-Python-Programmers.md:1192
msgid "See [this](http://rosettacode.org/wiki/Abstract_type#Nim)"
msgstr "Veja [isso] (http://rosettacode.org/wiki/Abstract_type#Nim)"

#: Nim.wiki/Nim-for-Python-Programmers.md:1194
msgid "Philosophy"
msgstr "Filosofia"

#: Nim.wiki/Nim-for-Python-Programmers.md:1195
msgid ""
"The key to understanding Nim is that Nim was designed to be as fast as C, but to be much safer. Many of the design decisions are based on making it harder to shoot yourself in the foot.\n"
"In Python, there are no pointers (everything is treated as a reference).\n"
"While Nim does give you pointers, Nim gives you other, safer tools for your everyday needs, while pointers are mostly reserved for interfacing with C and doing low-level system programming."
msgstr ""
"A chave para entender o Nim é que o Nim foi projetado para ser tão rápido quanto C, mas para ser muito mais seguro. Muitas das decisões de design são baseadas em tornar mais difícil dar um tiro no próprio pé.\n"
"Em Python, não há ponteiros (tudo é tratado como referência).\n"
"Enquanto o Nim fornece dicas, o Nim oferece outras ferramentas mais seguras para suas necessidades diárias, enquanto os ponteiros são principalmente reservados para a interface com C e a programação de sistemas de baixo nível."

#: Nim.wiki/Nim-for-Python-Programmers.md:1197
msgid ""
"Contrarily to Python, most Nim code can be executed at compile time to perform meta-programming.\n"
"You can do a lot of the DSLs possible with Python decorators/metaprogramming with Nim macros and pragmas.\n"
"(And some stuff that you can't!). Of course, this requires some different patterns and more type safety."
msgstr ""
"Ao contrário do Python, a maior parte do código Nim pode ser executada em tempo de compilação para realizar metaprogramação.\n"
"Você pode fazer muitas das DSLs possíveis com decoradores/metaprogramação Python com macros e pragmas Nim.\n"
"(E algumas coisas que você não pode!). Obviamente, isso requer alguns padrões diferentes e mais segurança de tipos."

#: Nim.wiki/Nim-for-Python-Programmers.md:1199
msgid "[ :arrow_up: :arrow_up: :arrow_up: :arrow_up: ](#table-of-contents \"Go to top\")"
msgstr "[:arrow_up: :arrow_up: :arrow_up: :arrow_up:] (#table -of-contents “Ir para o topo”)"
